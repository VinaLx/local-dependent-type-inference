\section{Discussions and Future Work}

\subsection{Open Terms Reduction}
\label{sec:open-term-reduction}

Usually only close terms are considered when designing the operational semantics,
and irreducible terms like variable are not considered as values.
But since the reduction relation $e_1 \longrightarrow e_2$ is also
used in typing relations, the reduced expressions can be open terms and well-typed under contexts.
\citet{full} observed this issue and included \emph{inert terms} as values
to capture the scenario that open terms like $x e$
(applying variable $x$ to the argument $e$) is also irreducible, which considerably
complicates their metatheory around operational semantics.
However since our call-by-name reduction relation only concerns when a term \emph{can} reduce
instead of when it \emph{can not} reduce
(there is no rule like ``if $e$ is a value, then $e_1 \longrightarrow e_2$'').
The definition of values does not matter when reasoning about
type-level reductions, we do not have to complicates the metatheory of our system
with inert terms.

% The type reduction in cast operators is potentially under a context that
% is not empty, so it is likely that we are performing reduction on an open term.
% Intuitively we should generalize the definition of value by introducing inert
% terms~\cite{full} to handle open term reduction.
% However since we adopt the call-by-name semantics of PITS~\cite{yang2019pure},
% there is no value check during the reduction. Whether the result of reduction
% inside a cast operator is a value or not does not matter during the reasoning of
% type safety. It is not necessary to complicate the metatheory by introducing inert terms.

\subsection{Design Choices of the Semantics around Cast Operators}
\label{sec:cast-design}

An alternative design around cast operators is the
call-by-value (CBV) style~\cite{yang2019pure},
by not considering all $\castup$ terms as values, and performing cast
elimination only when the expression inside two casts is a value.
Such design requires us to have a more general definition of value, and there would
be a need for inert terms as described in section \ref{sec:open-term-reduction}

However, a simple design with CBV-style cast semantics and inert terms
potentially leads to a system where \emph{Reduction Substitution} does not hold,
for example:
\begin{gather*}
    \castdn \, \castup \, [A] \, (f ~ x) \longrightarrow f ~ x \\
    [\lambda x : B. \, x / f] \, \castdn \, \castup \, [A] \, (f ~ x) \longrightarrow \castdn \, \castup \, [A] \, x
\end{gather*}

So we stick with the call-by-name style semantics around cast operators and
leave the discussion of other possibilities of design in future work.

\subsection{Kind Restrictions on Polymorphic Types}

Currently, we impose restrictions on the kinding of polymorphic types
($\forall x : A. B$) to require that they only have kind $\star$ but not $[[box]]$.
We believe that this has little impact on the usability
of our system since polymorphic kinds such as $\forall x : [[int]].\,\star$
do not appear frequently in practice.
However it would be reasonable not to have this restriction, but it would
complicate the development of the metatheory significantly.

One of the obstacles of removing the kind restriction is that
there is a mutual dependency between the transitivity theorem and the subtyping
reasoning of polymorphic kinds. We wish to have some lemma like this:
\begin{mathpar}
    \inferrule*[]
      {[[G |- e : A]] \\ [[G |- e : *]]}
      {[[G |- * <: A : box]]}
\end{mathpar}
\noindent which depends on transitivity when the derivation of $[[G |- e : A]]$
ends with subsumption rule (\rref{s-sub}).

Note that the reverse variant of the lemma
(If $[[G |- e : A]]$ and $[[G |- e : *]]$ then $[[G |- A <: * : box]]$) is not generally
true. A counter example is $A : \star \vdash \forall a : A.\, \star \le \star$, which
does not hold if we are unable to find a well-typed instantiation of an
arbitrary type $A$, which breaks transitivity, while the derivation of the
first premise ends with \rref{s-forall-l}:
\begin{mathpar}
    \inferrule*[]
      {[[G |- [t / x] e1 <: e2 : *]] \\ [[G |- e2 <: e3 : B]] \\ [[G |- t : A]]}
      {[[G |- forall x : A. e1 <: e3 : *]]}
\end{mathpar}
We cannot apply \rref{s-forall-l} unless we can show $e_3$ is of type $[[*]]$.
One of the possiblities in this scenario is to show $[[G |- B <: * : box]]$,
which does not always hold for the reason discussed above.

Moreover, we expect complexities while reasoning about the kinding of types
after we lose the kinding uniqueness in other parts of the metatheory, therefore
we leave the relaxation of the kinding restrictions for future work.

\subsection{Runtime Relevance of Implicit Arguments}

In our language, the implicit arguments have no computational impact at runtime
and only provide the necessary scoping for type annotations. This is
a similar design to ICC~\cite{miquel2001implicit} and
ICC*~\cite{barras2008implicit} to simplify the development of a direct
operational semantics for our language. Such a restriction can be lifted if we
prove the runtime type-safety by elaboration to a second language,
such as \emph{the Calculus of Constructions}~\cite{coc},
instead of providing the direct operational semantics.

We can elaborate implicit function types (universal types) to $\Pi$ types,
implicit abstraction to lambda expression and implicit instantiation to explicit
application during type checking, when we have full information about the
choice of implicit instantiations. However the elaboration on a unified subtyping
system is not an easy task, because the subtyping relation cannot simply be interpreted
to a coercion between values of different types, while half of our subtyping
rules involve the subtype relation between terms instead of types.
Therefore we leave the exploration of how elaboration can be done
on a unified subtyping system as future work.

\subsection{Algorithmic System and Challenges}

\name does not currently have an algorithmic system since we
consider a formalized algorithm for dependent type system itself a substantial challenge so it
is left for future work. While trying to compare to existing algorithmic systems
for higher-ranked polymorphic type inference for System F-like languages
~\cite{dunfield2013complete,zhao19mechanical},
we identify the following challenges to develop an algorithmic system for \name.

\paragraph{Unification Inside Binders}
In dependent type systems, function types ($\Pi$ types) are dependent:
the type of applications potentially depends on the values of their arguments.
Therefore the unification problem we meet is potentially inside binders and
depends on the value of the arguments. For an extreme example in our language:

\begin{equation*}
    \lambda F : [[int]] \rightarrow [[*]].\, \lambda f : F~42 \rightarrow [[int]].\, f ((\Lambda A : \star.\,\mu x : A.\, x)~42)
\end{equation*}

Here the type of $\Lambda A : \star.\,\mu x : A.\, x$ should be $\forall A : \star.\, A$.
In a non-dependent setting, one can easily conclude the instantiation for type $A$ to be
$F~42 \rightarrow [[int]]$. However in our system, the type of $A$ is a
dependent function type, with the shape of $(\Pi x : [[int]].\, F~e)$,
where expression $e$ satisfies the equation $[42/x]\,e = 42$ according to \rref{s-app}.
% Since implicit type-level computation is not allowed in our system,
% the unification problem here remains to be first order.
Here we have two choices for the instantiation of $e$, namely $x$ and $42$,
but neither choice ($\Pi x.\, F~x$ or $\Pi x.\, F~42$) for type $A$ leads to a more general
solution than choosing the other.

Notably for a similar reason, the decidable
fragment of higher-order unification~\cite{patternunification} specifically
forbids scenarios where a unification variable applies to constants.
The case shown above is similar, where the ``application'' is $A~42$
(dependent function type $A$ ``applies'' to 42) with unification variable $A$,
while slightly different, because our system do not allow implicit type-level
computation (hence unifications remain at first-order),
the choices of $A$ are restricted to $\Pi x : [[int]].\,F~e_1$ where $[42/x]\,e_1 = 42$,
rather than $\Pi x : [[int]].\, e_2$ where $[42/x]\,e_2 = F~42$ in
higher-order unification.

There are potentially multiple approaches to this problem. For example, we can
impose a similar restriction to the pattern unification and refuse to solve
this kind of conflicts entirely, or we can only infer non-dependent function types when
facing a unification variable, which is the choice by \citet{dh}. But which is
the proper method for our system remains to be studied.

% However, we still face the
% problems with substitutions. For example, in the program above,
% the expression $e$ has two solutions, namely variable $x$
% and $42$.\bruno{So what's the problem of multiple solutions: explain that here.
%   No principal type? The two types are incomparable? If we pick one over the other then
% something may not type-check afterwards?}
%We consider coming up with a formal system a challenging problem to
%resolve the general issues that this example implies.

\paragraph{Inhabitation Problem}

In polymorphic subtyping, we do not need a ``real'' instantiation to conclude
that a subtyping relation holds. For example, in polymorphic subtyping:
\begin{equation*}
    \forall A.\, (A \rightarrow A) \rightarrow [[int]] \le (\forall A.\, A \rightarrow A) \rightarrow [[int]]
\end{equation*}
\noindent holds by first applying rule $\forallL$ with a dummy instantiation,
say $[[int]]$, and then showing $\forall A.\, A \rightarrow A \le [[int]] \rightarrow [[int]]$.
This clearly holds by applying rule $\forallL$ again. However such dummy instantiations
pose extra difficulties in \name:
\begin{equation*}
    \forall A : T.\, (A \rightarrow A) \rightarrow [[int]] \le (\forall A : T.\, A \rightarrow A) \rightarrow [[int]]
\end{equation*}
We cannot apply \rref{s-forall-l} until we find a valid instantiation for type $A$,
therefore we encounter an \emph{inhabitation problem} for \name. This problem is
undecidable for System F~\cite{dudenhefner2019simpler}. We do not expect it to be
decidable in a more complicated system with strong normalization.
Since we support general recursion in our language with a mono-expression
restriction we expect that all types are
inhabited. However, we currently do not have the proof backing the claim that
this is the case.
