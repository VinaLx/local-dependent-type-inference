\section{\System}
\label{sec:system}

This section introduces the static and dynamic semantics of
\name: a dependently typed calculus with type casts
and implicit polymorphism. The calculus employs
\emph{unified subtyping}~\cite{full}
and has a single relation that generalizes both typing and subtyping.
The calculus can be seen as a variant of the \emph{Calculus of Constructions}~\cite{coc},
but it uses a simple form of casts~\cite{isotype,yang2019pure} instead of the
conversion rule and features unrestricted recursion.
We present syntax, unified subtyping, and reduction for \name.

\begin{figure}[t]
\centering
\begin{equation*}
\begin{array}{llcl}
    \text{Kinds} & k & ~\Coloneqq ~ & [[*]] \mid [[box]] \\
    \text{Expressions} & e, A, B & ~ \Coloneqq ~ & [[x]] \mid [[n]] \mid [[k]] \mid [[int]] \mid [[e1 e2]] \mid [[lambda x : A. e]] \mid [[pi x : A. B]] \\
        & & \mid & [[bind x : A. e]] \mid [[forall x : A. B]] \mid [[mu x : A. e]] \\
        & & \mid & [[castup [A] e]] \mid [[castdn e]]   \\
    \text{Mono-Expressions} ~ & \tau, \sigma & ~ \Coloneqq ~ & [[x]] \mid [[n]] \mid [[k]] \mid [[int]] \mid \tau_1 ~ \tau_2 \mid \lambda \, x : \tau. ~ \sigma \mid \Pi \, x : \tau. ~ \sigma \\
        & & \mid & \Lambda \, x : \tau. ~ \sigma \mid \mu \, x : \tau. ~ \sigma \mid \castup \, [\tau]~ \sigma \mid \castdn \, \tau \\
    \text{Values} & v & ~ \Coloneqq ~ & [[k]] \mid [[n]] \mid [[int]] \mid [[lambda x : A. e]] \mid [[pi x : A. B]] \mid [[bind x : A. e]] \\
        & & \mid & [[forall x : A. B]] \mid [[castup [A] e]] \\
    \text{Contexts} & \Gamma & ~ \Coloneqq ~ & [[nil]] \mid [[G , x : A]] \\
    \text{Syntactic Sugar} ~ & A \rightarrow B & \triangleq & [[pi x : A. B]] \qquad \text{where} ~ x \notin \mathrm{FV}(B)
\end{array}
\end{equation*}
\caption{Syntax of \name.}
\label{fig:syntax}
\end{figure}
\subsection{Syntax}

Figure \ref{fig:syntax} shows the syntax of \name. The syntax is similar
to the Calculus of Constructions, featuring
$[[*]]$ and $[[box]]$ in the kind hierarchy, and unifying the concepts of terms
and types as expressions. Due to the unified syntax, types and
expressions ($e$, $A$ and $B$) are used
interchangeably, but we mostly adopt the convention of using $A$ and $B$
for the contexts where the expressions are used as types and $e$ for contexts
where the expressions represent terms.
The syntax includes all the constructs of the calculus of constructions:
variables ($[[x]]$), kinds ($[[k]]$), function applications  ($[[e1 e2]]$),
lambda expressions ($[[lambda x : A. e]]$), dependent function types ($[[pi x : A. B]]$)
as well as integer types ($[[int]]$) and integers ($[[n]]$).
Moreover, there are several additional language constructs for
supporting implicit polymorphism, recursion, and explicit type-level computation
via casts. These constructs are discussed next.

\paragraph{Implicit Polymorphism}
% In \name, universal types $[[forall x : A. B]]$ are used to generalize implicit
% polymorphism.
In \name, universal types $[[forall x : A. B]]$ generalizes the implicit
polymorphic type ($\forall x.\, A$) in conventional functional languages,
% In contrast to universal quantification in conventional functional languages, the
% parameter $x$ ranges over all well-typed expressions besides well-formed
% types (i.e. $x$ can have any type $A$ instead of just kind $\star$).
while the parameter $x$ ranges over all well-typed expressions besides well-formed
types (i.e. $x$ can have any type $A$ instead of just kind $\star$). The idea of
\emph{monomorphic types}(or monotypes) is also generalized.
\emph{Mono-expressions} $\tau$ exclude polymorphic types from the syntax,
which follows a similar design in various work about predicative
higher-ranked polymorphism~\cite{odersky1996putting,dunfield2013complete,jones2007practical}.
With dependent types, we choose to only excludes the universal types, but not
any other related expressions.

Notably,
% In other words,
generalized ``polymorphic types'' are naturally dependent, and $\forall$
types can be viewed as the implicit counterpart of $\Pi$ types.
So we also have implicit lambda expressions ($[[bind x : A. e]]$),
% , which are the implicit counterpart of $\lambda$ abstractions
which is different from the ``usual'' $\lambda$ expressions and explicit function
types ($\Pi$ types), for which arguments should be explicitly passed. The argument
of implicit lambda ($\Lambda$) expressions are deduced during type checking.
.
% The design used in \name
This is a similar design to
% is similar to the design of
the \emph{Implicit Calculus of Constructions} ($\text{ICC}^*$)~\cite{barras2008implicit}, which
employs similar constructs for implicit dependent products.
% Like conventional universal quantification, the arguments of $\forall$ types are
% deduced during applications rather than explicitly passed.

% Also, following the designs for predicative higher-ranked
% polymorphism~\cite{odersky1996putting,dunfield2013complete,jones2007practical},
% we have generalized the concept of \emph{monotypes} to
% \emph{mono-expressions} ($\tau$), essentially excluding $\forall$ types from expressions.

\paragraph{Recursion and Explicit Type-level Computation}
\label{sec:cast}
The \name calculus adopts \emph{iso-types}~\cite{isotype,yang2019pure},
featuring explicit type-level computation with cast operators
$\castdn$ and $\castup$. These operators respectively perform one-step
type reduction and type expansion based on the operational semantics.
The reduction in cast operators is deterministic, thus type
annotations are only needed during type expansions ($\castup$). We add
fixpoints ($[[mu x : A. e]]$) to support general recursion for both
term-level and type-level. Iso-recursive types are supported due to
the presence of $\castup$ and $\castdn$, which correspond to the
\verb|fold| and \verb|unfold| operations when working on iso-recursive types.

\subsection{Operational Semantics}\label{subsec:semantics}

For the operational semantics we employ two different but closely related
reduction relations. The first reduction relation is non-deterministic, and
it is used at the type-level to allow type conversions induced
by the cast operators. The second reduction relation is deterministic and
is employed to give the run-time semantics of expressions.

\paragraph{Nondeterministic Reduction}
Figure \ref{fig:semantics} presents the small-step operational semantics of our system,
which mostly follows the call-by-name variant of \emph{Pure Iso-Type Systems} (PITS)
~\cite{yang2019pure} corresponding to the calculus of constructions.
Note that the arguments of the $\beta$-reduction (\rref{r-beta}) and expressions in
the \rref{r-cast-elim} are not required to be values.
Meanwhile, we consider $\castup$ terms to be a value,
and only perform reduction inside $\castdn$ terms (\rref{r-castdn}). Also, the unfold
operation of the fixpoint operator is supported by \rref{r-mu}.

\begin{figure}[t]
    \centering

    \begin{drulepar}[r]{$[[e1 --> e2]]$}{Operational Semantics}
      \drule{app}
      \drule{beta}
      \and \ottaltinferrule{r-inst}{}{ }
        {[[(bind x : A. e1) e2 --> ([t / x] e1) e2]]}
      \drule{mu}
      \drule{castdn}
      \and \ottaltinferrule{r-cast-inst}{}{ }
        {[[castdn (bind x : A. e) --> castdn ([t / x] e)]]}
      \drule{castXXelim}
    \end{drulepar}

    \caption{Operational semantics of \name.}
    \label{fig:semantics}
\end{figure}

Due to the presence of the instantiation of implicit parameters, the direct operational
semantics is not deterministic, and potentially not type-preserving because of
\rref{r-inst,r-cast-inst}. The indeterminacy is caused by the guess of $\tau$,
which can be an arbitrary mono-expression, since we do not have access to any typing
information in the dynamic semantics.

\begin{figure}
  \centering
  \begin{equation*}
  \begin{array}{llcl}
      \text{Erased Expressions} & E, A, B & ~ \Coloneqq ~ & [[x]] \mid [[n]] \mid [[k]] \mid [[int]] \mid [[ee1 ee2]] \mid [[elambda x. ee]] \mid [[epi x : eA. eB]] \\
      & & \mid & [[ebind x. ee]] \mid [[eforall x : eA. eB]] \mid [[emu x. ee]] \mid [[ecastup ee]] \mid [[ecastdn ee]] \\
      \text{Erased Value} & ev & ~ \Coloneqq ~ & [[k]] \mid [[n]] \mid [[int]] \mid [[elambda x. ee]] \mid [[epi x : eA. eB]] \mid [[ebind x. ee]] \\
      & & \mid & [[eforall x : eA. eB]] \mid [[ecastup ee]]
  \end{array}
  \end{equation*}

  \begin{gather*}
    \begin{align*}
    \extract{[[x]]} &= [[x]] &
    \extract{[[n]]} &= [[n]] &
    \extract{[[k]]} &= [[k]] &
    \extract{[[int]]} &= [[int]]
    \end{align*} \\
    \begin{align*}
     \extract{[[e1 e2]]} &= \extract{[[e1]]} ~ \extract{[[e2]]} & % \\ % \and
      \extract{[[mu x : A. e]]} &= \mu \, x. ~ \extract{[[e]]} \\
     \extract{[[lambda x : A. e]]} &= \lambda \, x. ~ \extract{[[e]]} & % \\ % \and
      \extract{[[pi x : A. B]]} &= \Pi \, x : \extract{[[A]]}. ~ \extract{[[B]]} \\
     \extract{[[bind x : A. e]]} &= \Lambda \, x. ~ \extract{[[e]]} & % \\ % \and
      \extract{[[forall x : A. B]]} &= \forall \, x : \extract{[[A]]}. ~ \extract{[[B]]} \\
     \extract{[[castup [A] e]]} &= \castup \, \extract{[[e]]} & % \\ % \and
      \extract{[[castdn e]]} &= \castdn \, \extract{[[e]]}
    \end{align*}
  \end{gather*}

  \drules[er]{$[[ee1 *--> ee2]]$}{Erased Semantics}
    {app,beta,elim,mu,castdn,castXXinst,castXXelim}
  \caption{Erased Expressions and Operational Semantics}
  \label{fig:extraction}
\end{figure}

\paragraph{Deterministic Reduction}
We address the issue of determinacy of the dynamic semantics with
a design similar to $\mathrm{ICC}^*$~\cite{barras2008implicit},
employing type-erased expressions. The erased expressions
essentially mirror the syntax and semantics
of normal expressions, except for the elimination of type annotations in $\lambda$,
$\Lambda$, $\mu$ and $\castup$ expressions.
Figure \ref{fig:extraction} shows the syntax of the erased expressions and
the companion operational semantics. Note that restrictions are imposed in the
typing rules to forbid the implicit parameter occurring in runtime-relevant part
of the expression, i.e. the erased expressions (see Section \ref{sec:type-system}).
With such restriction, implicit parameters can be directly eliminated in
\rref{er-elim,er-cast-inst}. For a well-typed expression, the reduction of
its erasure is deterministic. The type safety of our system is built around
this idea and is discussed in Section \ref{sec:type-safety}.



\subsection{Unified Subtyping}
\label{sec:type-system}

Figure \ref{fig:typing} shows the (sub)typing rules of the system. We adopt a
simplified design of unified subtyping~\cite{full}, where the subtyping rules and
typing rules are merged into a single typing judgment $[[G |- e1 <: e2 : A]]$.

Unified subtyping solves the challenging issue of mutual dependency between typing
and subtyping in a dependent type system.
The interpretation of this judgment is ``under context $[[G]]$, $[[e1]]$ is a
subtype of $[[e2]]$ and they are both of type $[[A]]$''.
In this form of formalization, the typing judgment $[[G |- e : A]]$ is a
special case of unified subtyping judgment $[[G |- e <: e : A]]$,
and the well-formedness of types $\Gamma \vdash A$ is expressed by
$[[G |- A : k]]$ where $k \in \{[[*]], [[box]]\}$.

Although unified, the typing rules can still be viewed as two parts, the ``typing'' part
(\rref{s-abs,s-app,s-bind,s-mu,s-castup,s-castdn,s-sub}) and the ``subtyping'' part
(\rref{s-pi,s-forall,s-forall-l,s-forall-r}). We follow a usual design for
typing rules for lambda abstraction and application, and the subtyping rule of
dependent function types ($\Pi$ type).

\begin{figure}
    \centering
    \begin{drulepar}[wf]{$[[|- G]]$}{Well-formed Context}
      \mprset{sep=1.2em}
      \drule{nil}
      \drule[width=30em]{cons}
    \end{drulepar}

    \begin{drulepar}[s]{$[[G |- e1 <: e2 : A]]$}{Unified Subtyping}
      \mprset{sep=1.3em}
      \drule{var}
      \drule{lit}
      \drule{int}
      \drule{star}
      % \drule{abs}
      \and \ottaltinferrule{abs}{width=20em}
        {\rulehl{[[G |- A : k1]]} \\ [[G, x : A |- B : k2]] \\ [[G, x : A |- e1 <: e2 : B]]}
        {[[G |- lambda x : A. e1 <: lambda x : A. e2 : pi x : A. B]]}
      % \drule{app}
      \and \ottaltinferrule{s-app}{}
        {[[G |- t : A]] \\ [[G |- e1 <: e2 : pi x : A. B]]}
        {[[G |- e1 t <: e2 t : [t / x] B]]}
      \drule{pi}
      % \drule{bind}
      \and \ottaltinferrule{s-mu}{width=20em}
        {[[G |- t : k]] \\ [[G , x : t |- s : t]]}
        {[[G |- mu x : t. s <: mu x : t. s : t]]}
      \and \ottaltinferrule{s-bind}{width=20em}
        {\rulehl{[[G |- A : k]]} \\ [[G , x : A |- B : *]] \\
         [[G, x : A |- e1 <: e2 : B]] \\
         x \notin \mathrm{FV}(\extract{[[e1]]}) \cup \mathrm{FV}(\extract{[[e2]]})}
        {[[G |- bind x : A. e1 <: bind x : A. e2 : forall x : A. B]]}
      % \drule{mu}
      \drule{castup}
      \drule{castdn}
      % \drule{forallXXl}
      \and \ottaltinferrule{s-forall-l}{width=20em}
        {\rulehl{[[G |- A : k]]} \\ [[G |- t : A]] \\
         [[G , x : A |- B : *]] \\
         [[G |- [t / x] B <: C : *]]}
        {[[G |- forall x : A. B <: C : *]]}
      % \drule{forallXXr}
      \and \ottaltinferrule{s-forall-r}{width=20em}
        {\rulehl{[[G |- B : k]]} \\ [[G |- A : *]] \\
         [[G , x : B |- A <: C : *]]}
        {[[G |- A <: forall x : B. C : *]]}
      % \drule{forall}
      \and \ottaltinferrule{s-forall}{width=20em}
        {\rulehl{[[G |- A : k]]} \\ [[G , x : A |- B <: C : *]]}
        {[[G |- forall x : A. B <: forall x : A. C : *]]}
      \and \ottaltinferrule{s-sub}{width=15em}
        {[[G |- e1 <: e2 : A]] \\ [[G |- A <: B : k]]}
        {[[G |- e1 <: e2 : B]]}
    \end{drulepar}

    % \drules[s]{$[[G |- e1 <: e2 : A]]$}{Unified Subtyping}{
    %     var,lit,int,star,abs,pi,app,bind,mu,castup,castdn,forallXXl,forallXXr,forall,sub}
    \begin{equation*}
       \text{Syntactic Sugar} \qquad [[G |- e : A]] \triangleq [[G |- e <: e : A]]
    \end{equation*}
    \caption{(Sub)Typing Rules of \name.}
    \label{fig:typing}
\end{figure}

\paragraph{Rules for Universal Quantification}
The subtyping rules for universal quantification (\rref{s-forall-l,s-forall-r}) follow
the spirit of the Odersky and L\"aufer's polymorphic subtyping~\cite{odersky1996putting,dunfield2013complete},
where the subtyping relation is interpreted as a ``more-general-than'' relation.
A polymorphic type $[[forall x : A. B]]$
is more general than another type $C$ when its well-typed
instantiation is more general than $C$ (\rref{s-forall-l}). A polymorphic
type $[[forall x : B. C]]$ is less general than a type $A$,
if $C$ is is less general than $A$ when the argument with the polytype ($x:B$)
is instantiated abstractly (\rref{s-forall-r}).

Notably, our formalization is not a direct generalization of Odersky and L\"aufer's
polymorphic subtyping:
\rref{s-forall} axiomatizes the subtyping relation between two polymorphic types.
Furthermore, additional premises are added to \rref{s-forall-l,s-forall-r} aside from the
ones we previously mentioned in Section \ref{sec:polymorphic-subtyping}.
The motivations for these changes are discussed in more detail in Section \ref{sec:adaptation}.

\paragraph{Mono-expression Restrictions}
As in other predicative relations (such as the one by Odersky and L\"aufer),
the type arguments for instantiation in \rref{s-forall-l} are
required to be mono-expressions, which has cascading effects on typing rules of
other expressions. The arguments for applications are required to be
mono-expressions, and the whole fixpoint expression is required to be a
mono-expression. We shall
discuss the reason behind these restrictions in Section \ref{sec:metatheory}.

\paragraph{Kind Restriction for Universal Types}
\label{sec:kind-restriction}

For the kinding of types, we mainly follow the design of the Calculus of
Constructions~\cite{coc}. However, we specifically restrict
the polymorphic type $[[forall x : A. B]]$ to only have kind $[[*]]$, but not $[[box]]$.
This restriction prevents types of kind $[[*]]$ from having implicit
polymorphic kind such as $[[forall x : int. *]]$ through
\rref{s-forall-l,s-forall-r,s-sub} (for example, $[[int]]$
is always of kind $[[*]]$ and can never be of kind $[[forall x : int. *]]$),
which significantly complicates the kinding reasoning of types in metatheory.

This restriction propagates to the introduction rule of $\forall$ types (\rref{s-bind}),
where $[[B]]$ is required to only have kind $[[*]]$.
Therefore implicit polymorphic functions at type level are never well-typed.
For example, $\Lambda n : [[int]].\, \lambda v : \mathrm{Vector}~n.\, [[int]]$ is not
well-typed since it is a polymorphic function that returns $[[int]]$,
which is of kind $[[*]]$.

% This way well-typed implicit abstractions ($\Lambda$ expressions) are kept away
% from type computations. Therefore, in cast operators,
As a result of well-typed implicit instantiation not occuring at type level,
% the possibility of non-deterministic implicit instantiations is eliminated.
the non-deterministic well-typed type-level reductions never occur,
although implicit instantiations seem to be allowed by the reduction rules.

\paragraph{Runtime Irrelevance of Implicit Arguments}

Our direct operational semantics chooses arbitrary mono-expressions to instantiate
the implicit arguments, which potentially breaks type safety. Thus, we adopt a
restriction in \rref{s-bind} that is similar to the
Implicit Calculus of Constructions (ICC)~\cite{miquel2001implicit}.
We only allow the implicit parameters to occur in type annotations in the
body of implicit abstraction, so that the choices of implicit parameters are not
relevant at runtime. The type safety of the direct operational semantics is
proved indirectly in Section \ref{sec:type-safety} with the help of the
erasure of expressions.

\paragraph{Redundant Premises}

All the premises highlighted in gray are redundant in a way that
the system without them is proved equivalent to the system with them.
These redundant rules are there to simplify the mechanized proofs of
certain lemmas, but can be safely dropped in an actual implementation.

