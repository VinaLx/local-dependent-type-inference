\section{Overview}
\bruno{Please fill in missing references.}

In this section we introduce \name by going through
some interesting examples to show the expressiveness and major features of the calculus.
Then we discuss motivation, rationale of our design and challenges.
The formal system of \name will be
discussed in Sections \ref{sec:system} and \ref{sec:metatheory}.

\subsection{A Tour of \name}
\label{sec:examples}

The \name calculus features a form of \emph{implicit
  higher-ranked polymorphism} with the power of dependent types. Thus the main feature of \name
is the ability to implicitly infer universally quantified arguments.

\paragraph{A First Example of Implicit Polymorphism}
Like most of functional languages, \name supports (implicit) parametric polymorphism.
A first simple example is the polymorphic identity
function:
\begin{flalign*}
&\mathrm{id} : \forall (A : \star).\, A \rightarrow A &&\\
&\mathrm{id} = \lambda (x : A).\, x &&\\
&\mathrm{answer} : \mathbb{N} &&\\
&\mathrm{answer} = \mathrm{id} ~ 42 \qquad \text{-- No type argument needed at the call of $\mathrm{id}$} &&
\end{flalign*}
\noindent The polymorphic parameter \verb|A| is annotated with its type,
which is $\star$. The type $\star$ is the type of types (also known as
\emph{kind}). In \name, the parameters of lambda abstractions are annotated
with their types, and the \verb|A| in the definition refers back to the
polymorphic parameter. Similarly to implicit polymorphism in other languages,
the polymorphic parameters of the $\forall$ types are implicitly instantiated
during applications. Thus, in the call of the identity function, we
do not need to specify the argument used for instantiation. In contrast,
in an explicitly polymorphic language (such as System F) we would need
to call $id$ with an extra argument that specifies the instantiation of $A$:
$\mathrm{id}~\mathbb{N}~ 42$.


\paragraph{Recursion and Dependent Types}

\name is dependently typed, and universal quantification is not limited to work
on arguments of type $\star$, but it allows arguments of other types. This is
a key difference compared to much of the work on type-inference for higher-ranked
polymorphism~\cite{}\bruno{reference to many (i.e. 5+) papers on that topic}, which has focused on System F-like
languages where universal quantification can only have arguments of type $\star$.
Furthermore \name supports general recursion at both the term and the type-level.

Using these features we can encode an indexed list, a \verb|map| operation over it
and illustrate how implicit instantiation allows us to use the \verb|map| function
conveniently.
However, because \name is just a core calculus there is no built-in support
yet for algebraic datatypes and pattern matching.
We expect that a source language would provide a more convinient
way to define the \verb|map| function using pattern matching and other useful source-level
constructs. To model algebraic datatypes and pattern matching in \name we
use an encoding by Yang and Oliveira~\cite{pits}, which is based on Scott encodings~\cite{}.
Since the details of that encoding are not relevant for this paper,
here we omit the code for most definitions and show only their types.

In a dependently typed language a programmer could write the following definition
for our formulation of indexed lists:
\newcommand{\Nat}[0]{\mathbb{N}}
\newcommand{\Succ}[0]{\mathrm{S}}
\newcommand{\Zero}[0]{\mathrm{Z}}
\newcommand{\List}[0]{\mathrm{List}}
\newcommand{\Nil}[0]{\mathrm{Nil}}
\newcommand{\Cons}[0]{\mathrm{Cons}}
\newcommand{\map}[0]{\mathrm{map}}
\begin{flalign*}
  & \mathbf{data} ~ \Nat = \Zero ~|~ \Succ~\Nat &&\\
  & \mathbf{data} ~ \List~(a : \star)~(n : \Nat) = \Nil ~ | ~ \Cons~a~(\List~a~(\Succ~n)) &&
\end{flalign*}
In \name we can encode the $\mathrm{List}$ and the constructors as conventional terms. We
show the definition for \verb|List|, and the types for the constructors (implementation ommitted)
next. In later subsequent examples we will just assume some Haskell-style
syntactic sugar for datatype definitions and constructors.
\begin{flalign*}
&\List : \star \rightarrow \Nat \rightarrow \star &&\\
&\List = \mu L : \star \rightarrow \Nat \rightarrow \star.\, \lambda a:\star.\, \lambda n :\Nat.\, \forall r:\star.\, r \rightarrow (a \rightarrow L~a~(\Succ ~ n) \rightarrow r) \rightarrow r &&\\
&\Nil : \forall a : \star.\, \forall n : \Nat.\, \List ~ a ~ n &&\\
%\Nil &=& \castup \castup (\lambda z : r.\, \lambda c : (a \rightarrow \List~a~n \rightarrow r). ~ z) \\
&\Cons : \forall a : \star.\, \forall n : \Nat.\, a \rightarrow \List ~ a ~ (\Succ ~ n) \rightarrow \List ~ a ~n &&
%\Cons &=& \lambda x : a.\, \lambda xs : \List~a~(\Succ ~ n).\, \castup \castup (\lambda z : r.\, (\lambda c : a \rightarrow \List~a~(\Succ ~ n) \rightarrow r). ~ c ~ x ~ xs)
\end{flalign*}
\noindent Then we can define a \verb|map| function over \verb|List| with the type:
\begin{flalign*}
%  & \map ' :: \forall a : \star.\, \forall b : \star. (a \rightarrow b) \rightarrow \Pi n : \Nat.\, (\List~a~n) \rightarrow (\List~b~n) \\
%  & \map ' = \lambda f : a \rightarrow b.\, \mu ~ rec : (\Pi n : \Nat.\, \List~a~n \rightarrow \List~b~n).\, \lambda xs : \List~a~n. \\
%  & \quad\qquad (\castdn \castdn \, xs) ~ \Nil ~ (\lambda x : a.\, \lambda xs' : \List~a~(\Succ~n).\, \Cons ~ (f ~ x) ~ (rec ~ (\Succ~n)~xs')) \\
%  \\
  & \map : \forall a : \star.\, \forall b : \star.\, \forall n : \Nat .\, (a \rightarrow b) \rightarrow \List~a~n \rightarrow \List~b~n &&
%  & \map = \lambda f : a \rightarrow b.\, \lambda xs : \List ~ a ~ n.\, \map '~f~n~xs
\end{flalign*}
An example of application of \verb|map| is:
% \bruno{You should make sure that code is formatted consistently (for instance centered or left
%   aligned) and using the same font. This isn't the case at the moment.
%   In this page alone there are at least 3 different variations being used.
%   Also, please be careful not to have too much vertical white space around the examples
%   (I've been fixing this, but please avoid it if you write/modify more code).
% }
\begin{flalign*}
&\map~\Succ~(\Cons~1~(\Cons~2~\Nil)) &&
\end{flalign*}

\noindent which increases every natural in the list by one.
Note that since the type parameters for \verb|map|, \verb|Cons| and \verb|Nil|
are all implicit, they can be all omitted
and the arguments are instantiated implicitly. Thus the \verb|map| function
only requires two explicit arguments, making it as convininent to use
as in most functional language implementations.

% \bruno{You are missing the most important/interesting portion of the code: i.e. show a call to
%   the map function and discuss how implicit polymorphism avoids having to specify 3 extra arguments
% to the function. In this page alone there are at least 3 different variations being used.}

There are a few final points worth mentioning about the example.
Firstly, \verb|List| is an example of a dependently typed function, since it is parametrized
by a natural value. Secondly, in \name (following the design of PITS~\cite{}),
fixpoint operators ($\mu$) serve a dual purposes of defining recursive types and recursive
functions. In \verb|List| the fixpoint operator is used to define a recursive type, whereas
in the definition of \verb|map| the fixpoint operator is used to define term-level recursion.
Moreover recursion is unrestricted and there is no termination checking, much like approaches
such as Dependently Typed Haskell~\cite{}, and unlike various other dependently typed languages
such as Agda~\cite{} or Idris~\cite{}.


\begin{comment}
  can not only be types, also values of other data types
(in this case, $\Nat$). So our language is able to directly encode the behavior of
``Datatype Promotion'' of GHC haskell. The type parameters of $\List$ at most
positions can be implicit parameter and instantiated during application.

\paragraph{Fixpoint Operators}
In our language, fixpoint operators ($\mu$) serves a dual purposes of defining
recursive data type and recursive functions. However we put restrictions on
fixpoint that its type can not be poly-type. So there is an awkward indirection
in the definition of $\map$ to make all of the type parameters implicit. The rationale
of this restriction is discussed in later sections.

\paragraph{Explicit Type-Level Computations}
The type-level computations of our language do not happen implicitly, they happen
explicitly when $\mathrm{cast}$ operators are used. $\castdn$ and $\castup$
generalize the ``unfold'' and ``fold'' of Iso-Recursive Types and invoke
one-step reduction or expansion respectively at type-level.
They also serve a role of wrapping and unwrapping the abstraction of data types.
\end{comment}

\paragraph{Implicit Higher-Kinded Types}

The implicit capabilities also extend to the realm of higher-kinded types~\cite{}. For example
we can define a \verb|Functor| datatype as:
\newcommand{\Functor}[0]{\mathrm{Functor}}
\newcommand{\MkFunctor}[0]{\mathrm{MkF}}
\newcommand{\Id}[0]{\mathrm{Id}}
\newcommand{\MkId}[0]{\mathrm{MkId}}
\newcommand{\fmap}[0]{fmap}
\begin{flalign*}
  &\mathbf{data}~\Functor~(F : \star \rightarrow \star) = \MkFunctor~\{\fmap : \forall a : \star.\, \forall b : \star.\, (a \rightarrow b) \rightarrow F~a \rightarrow F~b\} &&
\end{flalign*}
In this case the type of $fmap$ is:
\begin{flalign*}
  & \fmap : \forall F : \star \to \star.~\Functor~F \to \forall a : \star.\, \forall b : \star.\, (a \rightarrow b) \rightarrow F~a \rightarrow F~b &&
\end{flalign*}
%data constructor $\MkFunctor$ has type $\forall F : \star \rightarrow \star.\, \dots \rightarrow \Functor~F$ where the dots are the type of the field.
Importantly this example illustrates that universal variables can quantify over higher-kinds (i.e.
$F : \star \to \star$).
We can define instances of functor in a standard way:
\begin{flalign*}
  & \mathbf{data}~\mathrm{Id}~a=\MkId~\{runId : a\} && \\
  & \mathrm{idFunctor} : \Functor~\Id && \\
  & \mathrm{idFunctor} = \MkFunctor~\{\fmap = \lambda f : a \rightarrow b.\, \lambda ~x : \Id~a.\, \MkId~(f~(runId~x))\} &&
\end{flalign*}
and then use \verb|fmap| with three arguments:
\begin{flalign*}
& \fmap~\mathrm{idFunctor}~\Succ~(\MkId~0) &&
\end{flalign*}

\noindent Note that, because our calculus has no type classes we pass the ``instance'' explicitly.
Nonetheless three other arguments (the $F$, $a$ and $b$) are implicitly instantiated.

\paragraph{Higher-Ranked Polymorphic Subtyping}
\label{sec:higher-ranked-poly}

In calculi such as the ICC~\cite{}, a form of implicit instantiation also exists.
However, such calculi do not employ subtyping and instead they only apply instantiation
to top-level universal quantifiers. Our next example illustrates how subtyping enables
instantiation to be applied also in nested universal quantifiers, thus enabling
more types to be related.

When programming with continuations~\cite{} one of the functions that is typically needed
is call-with-current-continutation (\verb|callcc|). In a polymorphic language there are
several types that can be assigned to \verb|callcc|. One of these types is a rank-3 type,
while another one is a rank-1 type. Using polymorphic subtyping we can show that the rank-3
type is more general than the rank-1 type. Thus the following program type-checks:
\begin{flalign*}
& \mathrm{callcc}' : \forall a : \star.\, ((\forall b : \star.\, a \rightarrow b) \rightarrow a) \rightarrow a && \\
& \mathrm{callcc} : \forall a : \star.\, \forall b : \star.\, ((a \rightarrow b) \rightarrow a) \rightarrow a && \\
& \mathrm{callcc} = \mathrm{callcc}' &&
\end{flalign*}
\noindent The type $\forall b : \star.\, a \rightarrow b$ appears in a positive position
of the whole signature, and it is a more general signature than $a \rightarrow b$
for an arbitrary choice of $b$. Our language capture this subtyping relation so that
we can assign $\mathrm{callcc}'$ to $\mathrm{callcc}$ instead of the other way around.
In contrast, in approaches like the ICC, the types of \verb|callcc| and \verb|callcc'|
are not compatible and the example above would be rejected.

\subsection{Key Features}

We briefly discuss the major features of \name itself and
its formalization. A more formal and technical discussion will be left to
Sections \ref{sec:system} and \ref{sec:metatheory}.

\paragraph{The Polymorphic Subtyping Relation}
% \bruno{Have a figure and introduce the original relation here, before you move to
% giving an overview of the dependently typed version.}
Figure \ref{fig:polymorphic-subtyping} shows Odersky and L\"aufer polymorphic
subtyping relation~\cite{odersky1996putting}.
This relation captures a \emph{more-general-than} relation between
types as a subtyping relation. They key rules in their
subtyping relation are rules $\le\forall L$ and $\le\forall R$:

\begin{itemize}
  \item In rule $\le\forall L$, a polytype ($\forall x.\, A$) is considered \emph{more-general}
        than another type ($B$), when we can find an arbitrary monotype ($\tau$)
        so that the instantiation is more general than $B$.
        Importantly note that this relation does not guess arbitrary (poly)types,
        but just monotypes. In other words, the relation it \emph{predicative}~\cite{}.
        This restriction enusres that the relation is \emph{decidable}.
  \item In rule  $\le\forall R$ a type ($A$) is considered more general than a polytype ($\forall x. B$)
        when it is still more general than the head of polytype, with the type
        parameter instantiated by an abstract variable $x$.
\end{itemize}

This semantics of subtyping relation sets a scene for our work, which
to generalizes this relation to a dependently typed setting.

\begin{figure}
\centering

\begin{drulepar}{$\Gamma \vdash A \le B$}{Polymorphic Subtyping}
  \inferrule*[right=$\tau$]
    { }
    {\Gamma \vdash \tau \le \tau}
  \and
  \inferrule*[right=$\rightarrow$]
    {\Gamma \vdash B_1 \le A_1 \\ \Gamma \vdash A_2 \le B_2}
    {\Gamma \vdash A_1 \rightarrow A_2 \le B_1 \rightarrow B_2}
  \\
  \inferrule*[right=$\le\forall L$]
    {\Gamma \vdash \tau \\ \Gamma \vdash [\tau / x]\, A \le B}
    {\Gamma \vdash \forall x.\, A \le B}
  \and
  \inferrule*[right=$\le\forall R$]
    {\Gamma ,\, x \vdash A \le B}
    {\Gamma \vdash A \le \forall x.\, B}
\end{drulepar}

\caption{The polymorphic subtyping relation by Odersky and L\"aufer~\cite{odersky1996putting}.}
\label{fig:polymorphic-subtyping}
\end{figure}
% \bruno{Do not just show a few rules; show the complete relation (and the rule form).}


\paragraph{Generalizing Polymorphic Subtyping}
\label{sec:polymorphic-subtyping}

The parameters of universal types can only be types in the polymorphic
subtyping relation by Odersky and L\"aufer.
In \name, we generalize the polymorphic parameters so that they can
be can be values or other kinds of types as well.
A first attempt at a direct generalization would be:

\begin{mathpar}
  \inferrule*[right=$\le\forall L'$]
    {\Gamma \vdash \tau \rulehl{: A} \\ \Gamma \vdash [\tau / x]\, B \le C}
    {\Gamma \vdash \forall x \rulehl{: A}.\, B \le C}
  \and
  \inferrule*[right=$\le\forall R'$]
    {\Gamma ,\, x \rulehl{: B} \vdash A \le C}
    {\Gamma \vdash A \le \forall x \rulehl{: B}.\,C}
\end{mathpar}

\noindent Here the parameter for universal types can have any type (and not just $\star$).
Hence, instead of requiring the monotype $\tau$ to be a well-formed type in rule
$\le\forall L$, in rule $\le\forall L'$ it is
required that $\tau$ is well-typed regarding the type of the parameter
in the universal quantifier.
Similarly, for rule $\le\forall R'$ the context for the subtyping rule should include typing information
for the universaly quantified variable.

\paragraph{Higher-Ranked Polymorphic Subtyping}

As the \verb|callcc| example in Section \ref{sec:higher-ranked-poly} shows, these subtyping
rules based on polymorphic subtyping, combining with the normal subtyping rules
are able to handle the subtyping relations that occur at not only top-level,
but also higher-ranked level. This feature distinguish \name from the Implicit
Calculus of Constructions (ICC) \cite{miquel2001implicit} which also talks about
implicit polymorphism on dependent type language. The ICC features the two related rules
in the \emph{typing relation}:

\begin{mathpar}
  \inferrule*[lab=inst]
    {[[G |- e : forall x : A. B]] \\ [[G |- e1 : A]]}
    {[[G |- e : [e1 / x] B]]}
  \and
  \inferrule*[lab=gen]
    {[[G, x : A |- e : B]] \\ [[G |- forall x : A. B : k]]}
    {[[G |- e : forall x : A. B]]}
\end{mathpar}

\noindent Without an explicit subtyping relation, the ICC is not always able to handle subtyping
at higher-ranked positions. The approach taken by the ICC is similar to Hindley-Milner type system~\cite{},
which also features similar rules in typing. But Hindley-Milner is designed for dealing only with rank-1
polymorphism. In generalizations of higher-ranked polymorphic type-inference~\cite{},
it has been shown that rules like $\le\forall L$ and $\le\forall R$ generalize rules like
\textsc{GEN} and \textsc{INST}. Since we aim at higher-ranked polymorphic generalization,
we follow a similar, more general, approach in \name.

\paragraph{Unified Subtyping}
However, the $\le\forall L'$ and $\le\forall R'$ rules suffer from an
important complication, which does not exist in a System-F like setting: there is
a notorious mutual dependency between typing and subtyping.
In particular, note that rule $\le\forall L'$ now mentions the typing relation
in its premise ($\Gamma \vdash \tau : A$). Moreover, as usual,
the subsumption rule of
typing relation (shown below) depends on the subtyping relation.
\begin{mathpar}
  \inferrule*[right=t-sub]
    {\Gamma \vdash e : A \\ \Gamma \vdash A \le B}
    {\Gamma \vdash e : B}
\end{mathpar}
In contrast, in Odersky and L\"aufer's rules,
the same premise in $\le\forall L$ is only well-formedness ($\Gamma \vdash \tau$),
and thus subtyping does not depend on typing.
This mutual dependency problem has been a significant and notorious
problem when combining subtyping and dependent types~\cite{aspinall1996subtyping, hutchins2010pure},
and presents itself on our way to the direct
generalization of polymorphic subtyping.

To tackle this issue, we adopt a technique called
\emph{unified subtyping}~\cite{yang2017unifying}. Unified subtyping merges the typing relation and
subtyping relation into a single relation to avoid the mutual dependency:
\begin{mathpar}
  \Gamma \vdash e_1 \le e_2 : A
\end{mathpar}
The interpretation of this judgement is: under context $\Gamma$, $e_1$ is a subtype
of $e_2$ and they both are of type $A$. The judgements for subtyping and typing
are both special form of unified subtyping with the involvement of kind $[[*]]$:
\begin{mathpar}
  \Gamma \vdash A \le B \triangleq \Gamma \vdash A \le B : [[*]]
  \and
  \Gamma \vdash e : A \triangleq \Gamma \vdash e \le e : A
\end{mathpar}
The technique simplifies the formalization of dependently typed calculi with subtyping,
and especially the proof of transitivity in the original work. Ideally after applying the technique,
the generalization of the polymorphic subtyping should be:

\begin{mathpar}
  \inferrule*[right=$\le\forall''$]
    {\Gamma \vdash \tau : A \\ \Gamma \vdash [\tau / x]\, B \le C \rulehl{: [[*]]}}
    {\Gamma \vdash \forall x : A.\, B \le C \rulehl{: [[*]]}}
  \and
  \inferrule*[right=$\ge\forall''$]
    {\Gamma ,\, x : B \vdash A \le C \rulehl{: [[*]]}}
    {\Gamma \vdash A \le \forall x : B.\,C \rulehl{: [[*]]}}
\end{mathpar}

\noindent The basic idea of our own formalization essentially follows a similar design.
However, it is not exactly like this due to various issues, the
details will be discussed in Section \ref{sec:type-system}.

\paragraph{``Explicit'' Implicit Instantiation}

With polymorphic subtyping the instantiation of universally quantified type
parameters is done implicitly instead of being manually applied. In non-dependently
typed systems, \emph{implicit} parameters are types (i.e. terms are not involved in
implicit instantiation). For example:
\begin{mathpar}
  (\lambda x.\, x)~42 \longrightarrow 42
\end{mathpar}
\noindent Here $\lambda x.\, x$ has type $\forall A.\, A \rightarrow A$. The implicit
instantiation is not reflected anywhere at term level. However, in a
language with type annotations on parameters of binders
(for example lambda abstractions), in order
for the polymorphic variable to be well-scoped at type annotations of terms,
another binder $\Lambda$ is added for terms. However instantiations are still
implicit as shown in the following examples:
\begin{mathpar}
  (\Lambda A : [[*]].\, \lambda x : A.\, x) ~ 42 \longrightarrow 42
%  (\Lambda A : [[*]].\, \lambda x : A.\, \lambda y : A.\, x) \longrightarrow \lambda y : [[int]].\, 42
\end{mathpar}
Here $\Lambda A : [[*]].\, \lambda x : A.\, x$ has type $\forall A : \star. \, A \rightarrow A$,
and the polymorphic parameter $A$ is explicitly stated in the polymorphic
term. However as the reduction shows, the instantiations are still implicit.
We purposely omit the explicit binders for implicit parameters for all the examples
in Section \ref{sec:examples} for clarity, since such explicit binders can
be recovered with a simple form of syntactic sugar:

\[e : \forall (x : A) . B \hateq \Lambda (x : A). e : \forall (x : A) . B\]

\noindent When polymorphic parameters are used, \name provides a binder ($\Lambda (x : A). e$)
to ensure that the parameters are well-scoped at term-level.

\paragraph{Type-level Computation and Casts}

Since \name features a fixpoint that supports general recursion at both
type and term level. In order to avoid diverging computations at type checking,
we do not provide the congruence rule like other dependently
typed systems such as the Calculus of Constructions \cite{CoquandThierry1988Tcoc}
to support implicit type-level reduction.
\begin{mathpar}
  \inferrule*[lab=Cong]
    {[[G |- e : A]] \\ A =_\beta B}
    {[[G |- e : B]]}
\end{mathpar}
Instead, we partially adopt the
call-by-name design of \emph{Pure Iso-Type Systems} (PITS)~\cite{yang2016unified,yang2019pure},
and provide operators $\castdn$ and $\castup$ to explicitly trigger one-step
type reductions or expansions.\bruno{Show cast rules below.}
