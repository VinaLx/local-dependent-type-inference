\section{The Metatheory of \name}
\label{sec:metatheory}

This section presents the methatheory of \name, and discusses several challenges
that arised in the design of the rules to ensure the desired properties.

The three main results of the metatheory are:
\emph{transitivity of unified subtyping}, \emph{type-soundness} and
\emph{completeness with respect to Odersky and L\"aufer's} polymorphic
subtyping. Transitivity of subtyping is a general challenge for dependen type systems due
to the mutual dependency of typing and subtyping, and the Odersky and L\"aufer style
subtyping brings new issues to the table. For type-soundness the key challenge
is the non-deterministic and non type-preserving nature of the reduction relation.
To address this issue, we employ a type soundness proof technique
that uses the erased reduction relation shown in Section~\ref{}.
% \bruno{Check that the completeness lemma with respect to DK is discussed, and that the lemma
% that shows that redundant premises are indeed redundant are discussed as well.}


\begin{comment}
In this section, we introduce the design choices of \name to handle to challenge
brought by the dependent generalization of DK's declarative subtyping rules.
We also present the desired properties for \name to hold, which contribute to
the proof of transitivity and type safety.

Transitivity of subtyping is a general challenge for dependent type systems due
to the mutual dependency of typing and subtyping. Thankfully the Unified Subtyping
combines the two so there is only one judgement to reason about. Although
significantly simplified in one aspect, the DK's style subtyping brings new issues
on the table.

Although we have imposed restrictions on the implicit instantiation, they do not
change the indeterministic and non-type-preserving nature of the direct operational
semantics, due to not having access to typing information in the dynamic semantics.
So we choose a indirect path to show the type safety of \name.

And finally we expect the subtyping relation of \name to subsume the DK's
declarative subtyping.
\end{comment}

\subsection{Polymorphic Subtyping in a Dependently Typed Setting}
\label{sec:adaptation}
\bruno{I'm not entirely sure if this text belongs here or in a previous section.}

The polymorphic subtyping by Odersky and L\"aufer features the following two rules:

\begin{mathpar}
    \inferrule*[right=$\le\forall L$]
      {\Gamma \vdash \tau \\ \Gamma \vdash [\tau / x]\, A \le B}
      {\Gamma \vdash \forall x.\, A \le B}
    \and
    \inferrule*[right=$\le\forall R$]
      {\Gamma ,\, x \vdash A \le B}
      {\Gamma \vdash A \le \forall x.\, B}
\end{mathpar}

In order for the \emph{well-formedness}~\cite{dunfield2013lemmas} property
(\emph{If $\Gamma \vdash A \le B$, then $\Gamma \vdash A$ and $\Gamma \vdash B$})
to hold in L\"aufer and Odersky's system, these two rules rely on certain properties
that do not hold in our generalization. So we make several adjustments
in our adaptation to combat these issues, which resulted in the difference between
our current system and a direct generalization.

\subsubsection{Reverse Substitution of Well-Formedness.}
Rule $\le\forall L$ relies on the \emph{reverse substitution} property, but this property
does not hold in a dependently typed setting. Thus we need an alternative design that
still ensures well-formedness, but without relying on the reverse substitution property.

The reverse substitution property is:
\emph{If $\Gamma \vdash [B / x] \, A$ and $\Gamma \vdash B$, then $\Gamma,\, x \vdash A$}.
That is if we have a type $A$ with all occurrences of $x$ substituted by $B$ and $B$
is well-formed we can conclude that $A$ is well-formed under $\Gamma,\, x$.
A possible generalization of this property in a dependently typed setting would be:
\emph{If $[[G |- [B / x] A : *]]$ and $[[G |- B : C]]$, then $[[G , x : C |- A : *]]$}.
Since in a dependently-typed setting, the values of expressions also matter during typing
besides the types of expressions, a counter-example of the property is:

\begin{align*}
& F : [[int]] \rightarrow [[*]],\, a : F~42  \vdash (\lambda y : F~\rulehl{42}.\, [[int]]) ~ a : [[*]] \\
& F : [[int]] \rightarrow [[*]],\, a : F~42  \rulehl{,\, x : [[int]]} \vdash (\lambda y : F~\rulehl{x}.\, [[int]]) ~ a : [[*]]
\end{align*}

We cannot ``reverse substitute'' the $42$ in the type annotation to a variable
of same type, while the application expression depends specifically on the value
$42$ in order for the type of argument $a$ to match the parameter type.
So we add a premise $[[G , x : A |- B : *]]$ in \rref{s-forall-l} to directly
ensure the well-formedness of types in the conclusion.

\subsubsection{Strengthening of Contexts.}
\bruno{As far as I understand the discussion here + in Section 4.1 the strenghtening
  lemma does not hold even when considering that fixpoints are added to the language.
  Thus I think you should just show a counter-example here, avoid mentioning fixpoints
  at this point, and mention only fixpoints in Section~\ref{sec:instantiation}. Please rewrite
accordingly.}

Rule $\le\forall R$ relies on a standard strenghtening lemma:
\emph{if $\Gamma,\, x \vdash A$ and $x ~\text{is fresh in}~ A$, then $\Gamma \vdash A$}, which
is trivial to prove.
However its generalization:
\emph{if $[[G, x : B |- A : *]]$ and $x ~\text{is fresh in}~ A$},
is a much more difficult problem since we are no longer reasoning about
``well-formedness'' but also typing and subtyping. In our system the property
does not hold without the help of diverging programs with fixpoint operator,
we will come back to this issue in the section \ref{sec:instantiation}.

But for now, we add a premise $[[G |- A : *]]$ to \rref{s-forall-r},
requiring $A$ to be a well-typed type without the help of the fresh variable.
A consequence of adding this premise is that we will encounter a circular proof
while trying to prove $[[G |- forall x : A. B <: forall x : A . B : *]]$ for
arbitrary $A$ and $B$ by first applying \rref{s-forall-r}. We resolve this issue by
adding \rref{s-forall}.

\subsection{Typing Properties of \name}

With our rules properly set up, we can prove most of the basic properties
using techniques borrowed form the \emph{unifed subtyping}~\cite{} approach.
We introduce \emph{reflexivity}, \emph{weakening},
\emph{context narrowing}, \emph{substitution} and \emph{type correctness}
in this section.

\begin{theorem}[Reflexivity]
   If $[[G |- e1 <: e2 : A]]$,
   then $[[G |- e1 : A]]$ and $[[G |- e2 : A]]$.
\end{theorem}

Usually a subtyping relation is reflexive when any well-formed type is a subtype
of itself. With unified subtyping, the well-formedness of types is expressed by
subtyping relation as well, so the reflexivity looks more like the generalization
of \emph{well-formedness} mentioned in the previous section. Reflexivity
breaks down into two parts, \emph{left reflexivity} and \emph{right reflexivity}.

\begin{lemma}[Left Reflexivity]
   If $[[G |- e1 <: e2 : A]]$,
   then $[[G |- e1 : A]]$.
\end{lemma}

\begin{lemma}[Right Reflexivity]
   If $[[G |- e1 <: e2 : A]]$,
   then $[[G |- e2 : A]]$.
\end{lemma}

\noindent Both of the branches are proved by induction on the derivation of
$[[G |- e1 <: e2 : A]]$.
Left reflexivity and right reflexivity when derivations end with \rref{s-forall-l}
and \rref{s-forall-r} respectively are directly solved by \rref{s-forall}.

\begin{theorem}[Weakening]
    If $[[G1 ,, G3 |- e1 <: e2 : A]]$ and $[[|- G1 ,, G2 ,, G3]]$,
    then $[[G1 ,, G2 ,, G3 |- e1 <: e2 : A]]$.
\end{theorem}

\noindent \emph{Weakening} is proved by induction on the derivation of
$[[G1 ,, G3 |- e1 <: e2 : A]]$. The redundant premises discussed in Section
\ref{sec:type-system} help simplify the proof, by creating the induction
hypotheses about the type annotation of various expressions. Otherwise we are
not able to prove $[[|- G1 ,, G2 ,, G3 , x : A]]$ given only
$[[|- G1 ,, G3 , x : A]]$ and no help from induction hypotheses.

\begin{theorem}[Context Narrowing]
\label{thm:narrowing}
    If $[[G1 , x : B ,, G2 |- e1 <: e2 : C]]$ and $[[G1 |- A <: B : k]]$,
    then $[[G1 , x : A ,, G2 |- e1 <: e2 : C]]$.
\end{theorem}

\begin{lemma}[Well-formedness of Narrowing Context]
\label{thm:wf-narrowing}
   If $[[|- G1 , x : B ,, G2]]$ and $[[G1 |- A <: B : k]]$,
   then $[[|- G1 , x : A ,, G2]]$.
\end{lemma}

\noindent Theorem \ref{thm:narrowing} and lemma \ref{thm:wf-narrowing} are proved by
mutual induction on the derivations of $[[G1 , x : B ,, G2 |- e1 <: e2 : C]]$
and $[[|- G1 , x : B ,, G2]]$. \Rref{s-var} is the only non-trivial case to
solve: it relies on \emph{weakening} to conclude
$[[G1 , x : A ,, G2 |- A <: B : k]]$ from $[[G1 |- A <: B : k]]$, in order to
derive $[[G1 , x : A ,, G2 |- x : B]]$ through \rref{s-sub}.

\begin{theorem}[Substitution]
    If $[[G1 , x : A ,, G2 |- e1 <: e2 : B]]$ and $[[G1 |- t : A]]$,
    then $[[G1 ,, [t / x] G2 |- [t / x] e1 <: [t / x] e2 : [t / x] B ]]$.
\end{theorem}

\noindent Notably \emph{substitution} imposes a mono-expression restriction on the expression
being substituted with, which comes at a result of restricting the instantiation
of polymorphic parameter to only mono-expressions in \rref{s-forall-l}.

Take following derivation as an example:

\begin{mathpar}
    \inferrule*[Right=s-forall-l]
      {A : [[*]],\, F: A \rightarrow [[*]]\rulehl{,\, a : A} \vdash [\rulehl{a} / x]\, F ~ x \le F~\rulehl{a} : [[*]]}
      {A : [[*]],\, F: A \rightarrow [[*]]\rulehl{,\, a : A} \vdash \forall x : A.\, F ~ x \le F~\rulehl{a} : [[*]]}
\end{mathpar}

\noindent Assuming that we have no mono-expression restrictions on \emph{substitution}
and \rref{s-app}. If we substitute $a$ with an arbitrary poly-expression, the
derivation stops working because \rref{s-forall-l} requires a mono-expr
instantiation and \rref{s-app} requires the argument of both sides to be
syntactically the same.

Worth mentioning is that while poly-expressions breaks the subtyping aspect of the
\emph{substitution}, a special case of the substitution theorem that discusses
the typing of one expression
(If $[[G1 , x : A ,, G2 |- e : B]]$ and $[[G1 |- e1 : A]]$,
then $[[G1 ,, [e1 / x] G2 |- [e1 / x] e : [e1 / x] B]]$)
does not hold for similar reasons.
% \bruno{Hummm is this text correctly
%   written? The way I read it is that both subtyping and typing aspects break the lemma, but I suppose
% that what you want to say is that one aspect breaks but the other does not. Please rephrase more carefully.}.
% \Alvin{Yup, the seemingly only-typing version of the substitution doesn't hold}
Because in dependently-typed languages, substitutions are also involved in the types of
expressions as well. Due to the presence of \rref{s-sub}, we still have to
maintain the potential subtyping relation of the types of expressions after substitution,
for example:

\begin{mathpar}
    \inferrule*[Right=s-sub]
      {A : [[*]],\, F: A \rightarrow [[*]],\, a : A,\, b : \forall x : A.\, F~x \vdash b : \rulehl{\forall x : A.\, F~x}}
      {A : [[*]],\, F: A \rightarrow [[*]],\, a : A,\, b : \forall x : A.\, F~x \vdash b : \rulehl{F ~ a}}
\end{mathpar}

\noindent As a result, we put mono-expression restriction on the \emph{substitution} theorem,
as well as the typing rules involving expressions that potentially ``trigger''
substitutions during reductions, including the arguments of applications and the
fixpoint expressions.

\begin{lemma}[Context Well-formedness of Substitution]
\label{thm:wf-substitution}
   If $[[|- G1 , x : A  ,, G2]]$ and $[[G1 |- t : A]]$,
   then $[[|- G1 ,, [t / x] G2]]$.
\end{lemma}

\noindent After understanding the mono-expression restriction on \emph{substitution}, the actual
proof is not complicated: it proceeds by mutual induction with
lemma \ref{thm:wf-substitution} on the derivations of
$[[G1 , x : A ,, G2 |- e1 <: e2 : B]]$ and $[[|- G1 , x : A ,, G2]]$. When the
derivation ends with \rref{castup,castdn}, the proof
requires the reduction relation to preserve after the substitution.
This property should usually hold, but puts an interesting constraint which we
have to consider when designing the reduction rules (see section \ref{sec:cast-design}).

\begin{lemma}[Reduction Substitution]
   If $[[A --> B]]$, then $[[ [t / x] A --> [t / x] B ]]$
\end{lemma}

\begin{theorem}[Type Correctness]
    If $[[G |- e1 <: e2 : A]]$,
    then $\exists k.\, [[G |- A : k]]$ or $A = [[box]]$.
\end{theorem}

\noindent \emph{Type correctness} is a nice property that ensures that
what appears in the position of a type are actually types.
The theorem is proved by induction on the derivation of $[[G |- e1 <: e2 : A]]$,
the only non-trivial case is when the derivation ends with \rref{s-app}. We make
use of the substitution lemma and the inductive hypothesis to demonstrate the head
of $\Pi$ type preserve its kind after the argument is applied.

\subsection{Transitivity}

Transitivity is typically one of the most challenging properties to prove in
calculi with subtyping, and it was also one of the harder proofs in \name.
The proof of transitivity requires a generalization of the usual transitivity
property:

\begin{theorem}[Generalized Transitivity]
    If $[[G |- e1 <: e2 : A]]$ and $[[G |- e2 <: e3 : B]]$,
    then $[[G |- e1 <: e3 : A]]$.
\end{theorem}

\noindent where the types of the premises are potentially different.
To prove this property we employ sizes for the inductive argument. Moreover we rely on
a subtle property of uniqueness of kinds.

\begin{comment}
Usually \emph{transitivity} in a dependently-typed subtyping system is axiomized
in the declarative system.
Then a process is went through called the ``transitivity elimination'', which proves
the admissibility of transitivity in the declarative systems with the help of
their algorithmic version \cite{hutchins2010pure}\cite{aspinall1996subtyping}.
However Unified Subtyping help us simplify the process and prove the
transitivity directly\cite{yang2017unifying}. We prove the generalized
version of transitivity with the types of premises being potentially
syntactically different. Then the ``restricted'' version of transitivity follows directly.
\end{comment}


\subsubsection{Uniqueness of Kinds.} Assuming that the derivation of the second
premise of generalized transitivity ends with \rref{s-forall-r}, then we face the following problem:

\begin{mathpar}
    \inferrule*[]
      {[[G |- e1 <: e2 : A]] \\ [[G, x : B |- e2 <: C : *]]}
      {[[G |- e1 <: forall x : B. C : A]]}
\end{mathpar}

\noindent Before applying \rref{s-forall-r} to the conclusion, we have to establish the relationship
between $A$ and $[[*]]$. Were there no restrictions on the kinding of $\forall$ types,
this would be much more complicated situation, where the reasoning of kinding,
such as inversion lemmas of about kinds, and transitivity depend on each other.
This is one of the main reasons why we forbid $\forall$ types having kind $[[box]]$.
Then we can have the following theorem:

\begin{theorem}[Kind Uniqueness]
    If $[[G |- e : k]]$ and $[[G |- e : A]]$,
    then $A = k$.
\end{theorem}

\noindent The proof is achieved by generalizing the shape of $k$ to be
$\Pi x : A.\, \dots \Pi x : B.\, \dots k$ to generate useful inductive hypotheses
when the derivation of $[[G |- e : k]]$ ends with \rref{s-app}. Then the proof
proceeds with induction on the derivation of the generalized $[[G |- e : k]]$ and
assembling various lemmas of kinding to solve different cases.

With the help of \emph{Kind Uniqueness},
we ensure the equivalence of $A$ and $[[*]]$ on this and other similar situations.

\subsubsection{The Induction}

\emph{Generalized Transitivity} is proved by induction on the 3-tuple:

$$
\langle \#\forall([[e1]]) + \#\forall([[e2]]) + \#\forall([[e3]]), ~
\mathbf{size}([[e1]]) + \mathbf{size}([[e3]]), ~
\mathcal{D}_1 + \mathcal{D}_2 \rangle
$$

\noindent where $\#\forall$ counts the number of $\forall$s in the expression, $\mathbf{size}$ measures
the size of the syntax tree of the expression, $\mathcal{D}_1$ and $\mathcal{D}_2$ denote
the sizes of the derivation trees of the first and the second premises respectively.
The proof is mainly motivated by DK's transitivity proof of their subtyping system of
induction on the pair of $\langle \#\forall(e2) ,~ \mathcal{D}_1 + \mathcal{D}_2 \rangle$\cite{dunfield2013lemmas},
with adjustments to fit in our system.

The most problematic case to solve is when the first premise ends with \rref{s-forall-r},
and the second ends with \rref{s-forall-l}, essentially we have to show the following:

\begin{mathpar}
    \inferrule*[]
      {[[G , x : A |- e1 <: B : *]] \\ [[G |- [t / x] B <: e3 : *]]}
      {[[G |- e1 <: e3 : *]]}
\end{mathpar}

Here the only decreasing measure we can rely on is the fact that
$\#\forall([[ [t / x] B ]])$ is one less than $\#\forall([[forall x : A. B]])$.
This case is solved by applying the inductive hypothesis after performing
substitution on the premise $[[G , x : A |- e1 <: B : *]]$ using the fact that
$x$ does not occur in $e1$, obtaining $[[G |- e1 <: [t / x] B : *]]$.

The reason why we cannot directly copy DK's proof measure is because of the case
when both premises end with \rref{s-pi}, where we encounter the following problem:

\begin{mathpar}
    \inferrule*[]
      {[[G , x : A2 |- B1 <: B2 : k]] \\ [[G , x : A3 |- B2 <: B3 : k]] \\ [[G |- A3 <: A2 : k2]]}
      {[[G , x : A3 |- B1 <: B3 : k]]}
\end{mathpar}

The first and the second premise above do not share the same context, so they
must be unified with the help of the context narrowing lemma.
However context narrowing changes the size of derivation tree, so we are
not able to use the inductive hypothesis of $\mathcal{D}_1 + \mathcal{D}_2$.

Finally we have to make adjustments to solve the cases which preserve the
size of derivation tree, but not the sizes of the expressions.
Such scenario occurs when the first premise ends with \rref{s-forall-l},
where we face the following problem:

\begin{mathpar}
    \inferrule*[]
      {[[G |- [t / x] B <: e2 : *]] \\ [[G |- e2 <: e3 : C]]}
      {[[G |- forall x : A. B <: e3 : *]]}
\end{mathpar}

\noindent In this case $\#\forall({[[ [t / x] B]]})$ is one less than $\#\forall([[forall x : A. B]])$,
so it can be solved by applying \rref{s-forall-l} and the inductive hypothesis of $\#\forall(e_1)$.
And $\#\forall(e_3)$ is added to make the measure ``symmetric''
to deal with the contravariance case of \rref{s-pi}.

Finally, most of the cases that do not involve $\forall$ can be
solved with the help of the inductive hypothesis of
$\mathbf{size}(e_1) + \mathbf{size}(e_3)$. $\mathcal{D}_1 + \mathcal{D}_2$ solves
the cases where either premise ends with \rref{r-sub}, where the only decreasing
measure is the size of the derivation trees.

\begin{corollary}[Transitivity]
    If $[[G |- e1 <: e2 : A]]$ and $[[G |- e2 <: e3 : A]]$,
    then $[[G |- e1 <: e3 : A]]$.
\end{corollary}

\emph{Transitivity} is a special case of
\emph{Generalized Transitivity} where $A = B$.

\subsection{Type Safety}
\label{sec:type-safety}
% \bruno{You have been using the terminology extracted, whereas I think erased is more standard.
%   I've been trying to replace the terminology, but if you find more ``extracted'' occurrences, please
% replace those yourself.}

Since the reduction rules of \name do not have access to typing information, they
cannot perform valid instantiations of the implicit arguments during application,
leaving the runtime semantics nondeterministic and potentially non-type-preserving.

We tackle this issue by making the choice of implicit instantiation
irrelevant at runtime with the restrictions in \rref{s-bind}.
We define an erasure function (shown in figure \ref{fig:extraction})
% \bruno{This is the function that is shown earlier, right?
%   If so add a back reference to the figure here.}
that eliminates the type annotations
in some of the expressions ($\lambda$, $\Lambda$, $mu$ and $\castup$),
and keep the implicit parameter from occuring in the erased expressions.
This way the choices of implicit instantiation only affect the type annotation,
which should not be relevant for runtime computation.

We show that \name is type safe the sense that,
if an expression is well-typed, then the reduction of its erased version
does not ``go wrong''. Figure \ref{fig:extract-semantics} shows the semantics of
erased expressions. The erasure semantics mostly mirrors the semantics
shown in Figure \ref{fig:semantics}, except for \rref{er-elim,er-cast-elim}, which
conveys the idea of irrelevance of implicit instantiation by eliminating the
parameter directly.

\subsubsection{Progress} We show the \emph{progress} property for both the original expressions
and erased expressions.

\begin{theorem}[Progress]
    If $[[nil |- e : A]]$,
    then $\exists \, e'. \, e \longrightarrow e'$ or $e$ is a value.
\end{theorem}

\begin{theorem}[Progress on erased expressions]
    If $[[nil |- e : A]]$,
    then $\exists \, e'. \, \extract{e} \longrightarrow_E e'$ or $\extract{e}$ is an erased value.
\end{theorem}
% \bruno{You mean a rightarrow above instead of a left arrow, right?}

\noindent Both theorems are proved by induction on the derivation of $[[nil |- e : A]]$,
the proof is mostly straightforward except when the derivation ends with $\castdn$.
We use the fact that, for a well-typed expression whose type can reduce, that expression
cannot be a value unless it is a $\castup$ or $\Lambda$ expression.

\begin{lemma}[Reducible Type]
    If $[[G |- e : A]]$, $[[A --> B]]$ and $e$ is not $\castup$ or $\Lambda$ expressions,
    then $e$ is not a value.
\end{lemma}

This lemma is also useful for the proof of progress for erased expressions, since the
value definitions are very similar.

\begin{lemma}[Erased Value to Value]
    If $\extract{e}$ is an erased value, then $e$ is a value.
\end{lemma}

\begin{lemma}[Value to Erased Value]
    If $e$ is a value, then $\extract{e}$ is an erased value.
\end{lemma}


\subsubsection{Preservation}

%In this section we discuss the preservation theorem tailored by \name.
Since the direct operational semantics is not generally type-preserving and
deterministic because of the implicit instantiations, we show the
``preservation'' the help of the erased expressions (where implicit parameters
do not matter to the computation). For other reduction rules that do not involve
such issues, we discuss them as though we are proving a normal preservation
for brevity.

\begin{theorem}[Subtype Preservation]
    If $[[G |- e1 <: e2 : A]]$, $\extract{e_1} \longrightarrow_E E_1'$ and $\extract{e_2} \longrightarrow_E E_2'$,
    then $\exists\,e_1' \, e_2'.$ $\extract{e_1'} = E_1'$, $\extract{e_2'} = E_2'$, $e_1 \longrightarrow e_1'$, $e_2 \longrightarrow e_2'$ and $\Gamma \vdash e_1' \le e_2' : A$.
\end{theorem}

\begin{figure}
    \centering
    \begin{tikzcd}[row sep=large, column sep=large]
        e : A \arrow[r] \arrow[dashed]{d}[swap]{\text{Erasure}} & e' : A \\
        E \arrow[shorten=1mm]{r}[swap, pos=1]{E} & E' \arrow[dashed]{u}[swap]{\text{Annotation}}
    \end{tikzcd}
    \caption{Diagram for Erased Preservation without Subtyping}
    \label{fig:preservation}
\end{figure}
% \bruno{In the diagram you use ``E'' to denote erased expressions, but earlier when you define
%   the syntax for erased expressions and in earlier texts you use ``e''. You should be
%   consistent and I think using ``E'' everywhere for erased expressions is best.}


\noindent Figure \ref{fig:preservation} shows the idea of our preservation lemma without
considering the subtyping aspect
% \bruno{Are you trying to show a simplified version of the lemma here?
% Is this actually valid, or you're just trying to give an overview of the idea?}.
% \Alvin{The figure only talks about preservation of typing, the lemma shows the
% preservation of subtyping, they both hold, but only typing is clearer}
Here we use \emph{annotation} as the reverse process of erasure.
If an expression ($e$) is well-typed, and its erasure ($E$)
reduces to another erased expression ($E'$), we can find a ``annotated''
expression of $E'$ ($e'$) that is reduced by $e$ and also preserves the type $A$.
When no implicit instantiation happens in the reduction, then $e \longrightarrow e'$
is deterministic: i.e. it is just normal type preservation. When there is implicit
instantiation, if the erased expression can reduce, we show that there must
exist a valid instantiation for $e$ that preserves its type after the reduction, and
this instantiation only affects the type annotation.
In other words, the runtime semantics of \name can be implemented only with
erased expressions, when its annotation is well-typed.
Because for every step it reduces, we can find a corresponding annotation that
preserve the type of, and have the reduction relation with the
annotation of its expansion.

The theorem is proved by induction on the derivation of $[[G |- e1 <: e2 : A]]$,
cases for \rref{r-beta,r-mu} are solved with the substitution theorem,
cases \rref{r-app,r-castdn} are solved by inductive hypothesis. The interesting
ones are cases for \rref{r-cast-elim} and the implicit instantiation
(\rref{r-inst,r-cast-inst}).

\paragraph{Cast Elimination}
The main problem of cast elimination can be demonstrated by the following derivation:
% \bruno{Do you mention this problem before to
%   start the paragraph with this text? What is the relationship between Subtype Preservation for Types
%   and cast elimination? You should connect these better, and also motivate why a separate lemma
% for Subtype preservation of types is needed. }

\begin{mathpar}
    \hspace{-1.5cm}
    \inferrule*[Right=s-castdn]
      {\rulehl{[[B1 --> B2]]} \\ \inferrule*[Right=s-sub]
        {\rulehl{[[G |- A1 <: B1 : k]]} \\ \inferrule*[Right=s-castup]
          {\rulehl{[[A1 --> A2]]} \\ [[G]] \vdash [[e]] : \rulehl{A_2}}
          {[[G |- castup [A1] e : A1]]}}
        {[[G |- castup [A1] e : B1]]}}
      {[[G]] \vdash [[castdn (castup [A1] e)]] : \rulehl{B_2}}
\end{mathpar}

Here the typing of the inner $\castdn$ does not directly follow
\rref{r-castup}, but the subsumption rule instead. We want to show that after
the cast elimination (following \rref{r-cast-elim}), expression $e$ has type $B_2$,
while in reality it has type $A_2$. So we want to prove $\Gamma \vdash A_2 \le B_2$
with the information that $\Gamma \vdash A_1 \le B_1$, $[[A1 --> A2]]$
and $[[B1 --> B2]]$, which goes back to what we want to prove initially --
the subtype preservation, causing a circular dependency of proof.
% \bruno{I don't follow this last sentence}.
This problem was also observed by the previous work on unified subtyping
with the cast operators\cite{yang2017unifying}. They solved this situation
by a delicate approach with the help of an essential lemma
\emph{Reduction Exists in the Middle} (If $[[G |- e1 <: e2 : A]]$, $[[G |- e2 <: e3 : A]]$
and $e_1 \longrightarrow e_1'$, $e_3 \longrightarrow e_3'$, there exists $e_2'$
such that $e_2 \longrightarrow e_2'$). Unfortunately this lemma does not hold
in our system since universal types, which is not reducible, can appear in the middle of
two reducible types, so we cannot adopt their proof.
% \bruno{What lemma? briefly explain.}

We tackle this problem from another direction, with the observation that the
demand for subtyping preservation shifts from the ``terms'' to the ``types''.
With the CoC-like kind hierarchy, we have only limited layers in types.
In fact, we only need to go down one layer in the type hierarchy to be able to
obtain subtype preservation directly, since there is no subtyping involved at kind level,
hence no problem for the cast elimination there.
Even better, we show that by going down one level in the type hierarchy, the options
for the reduction that can be performed by a well-typed term are very limited.
Implicit abstractions do not occur in type computation due to the kind
restriction of $forall$ types. Cast operators also do not occur in type-level computation,
since we prove that well-typed reduction never occur at kind level.

\begin{figure}
    \drules[dr]{$[[A1 ==> A2]]$}{Deterministic Reduction}
      {app,beta,mu}
    \caption{Deterministic Reduction.}
    \label{fig:deterministic-reduction}
\end{figure}

Figure \ref{fig:deterministic-reduction} shows the effective reduction rules
inside cast operators.

\begin{lemma}[Deterministic Reduction]
    If $[[A ==> A1]]$ and $[[A ==> A2]]$,
    then $A_1 = A_2$.
\end{lemma}

\begin{lemma}[Deterministic Type Reduction]
    If $[[G |- A1 : k]]$ and $[[A1 --> A2]]$,
    then $[[A1 ==> A2]]$.
\end{lemma}

The cases for implicit abstractions are easy to prove. For the cast operators
we have the following lemma.

\begin{lemma}[Expressions of kind $[[box]]$ are never reduced]
    If $[[A --> B]]$ and $[[G |- e : A]]$,
    then $B$ does not have type $[[box]]$.
\end{lemma}

And then the subtype preservation of type computation can be easily shown.

\begin{lemma}[Subtype Preservation for Types]
    If $[[G |- A1 <: B1 : k]]$, $[[A1 ==> A2]]$ and $[[B1 ==> B2]]$,
    then $[[G |- A2 <: B2 : k]]$.
\end{lemma}

\bruno{I think that, at the start of the explanation, a better high-level description
  of what's going on is needed. You need to state that we are interested in two different
  subtype preservation lemmas, because reduction is used in two different ways (at runtime
  and at the type-level). Moreover reudction at the type-level is the usual one (not erased), whereas
  at runtime we use (or can use) erased reduction. Then briefly state that each of those results
has some associatted challenges. }

\paragraph{Implicit Instantiations}
The proof of two cases for implicit instantiations (\rref{r-inst,r-cast-inst})
are quite similar. They both makes use of the observation that, the implicit
instantiations are only triggered by \rref{s-forall-l}, which is exactly where
polymorphic types are instantiated. The implicit arguments are the
mono-expressions that instantiate polymorphic types. The result types of the
implicit instantiations are exactly the instantiation of the polymorphic types.
Then the rest of the proofs are finished by standard inversion lemmas,
with the help of the substitution lemma for the instantiations.

\subsection{Equivalence of a Simplified Language}

We mention in section \ref{sec:type-system} that some of the premises in the
typing rules are redundant. They helps in the formalization, but the system
is equivalent to the system without them. We define system
$[[G |= e1 <: e2 : A]]$, whose rules are the same as the typing rules of \name
, but with all redundant premises eliminated. Also, \rref{s-castdn,s-castup}
are also simplified to use deterministic reduction ($A \longrightarrow_D B$)
instead of the reduction rule $A \longrightarrow B$.

We prove the two system equivalent.

\begin{theorem}[Equivalence of \name and the Simplification]
  If $[[G |- e1 <: e2 : A]]$ then $[[G |= e1 <: e2 : A]]$.
  If $[[G |= e1 <: e2 : A]]$ then $[[G |- e1 <: e2 : A]]$.
\end{theorem}

\subsection{Subsumption of Polymorphic Subtyping}

Finally we show that the subtyping aspect of \name subsumes the Odersky and L\"aufer's declarative
subtyping~\cite{??}.

\begin{figure}
    \begin{mathpar}
        \lift{x} = x \and \lift{[[int]]} = [[int]] \and
        \lift{A \rightarrow B} = \lift{A} \rightarrow \lift{B} \and
        \lift{\forall x. \, A} = \forall x : [[*]]. \, \lift{A} \and
    \end{mathpar}
    \begin{mathpar}
        \lift{[[nil]]} = [[nil]] \and
        \lift{\Gamma, \, x} = \lift{\Gamma},\, x : [[*]]
    \end{mathpar}
    \caption{Lifting Types and Contexts in DK's Sutyping to \name}
    \label{fig:lift}
\end{figure}

Figure \ref{fig:lift} shows the transformation from polymorphic subtyping to \name.
Then we prove the subsumption in terms type well-formedness and subtyping
by following the interpretation of unified subtyping.

\begin{theorem}[Subsumption of Type Well-formedness]
    If $\Gamma \vdash A$, then $\lift{\Gamma} \vdash \lift{A} : [[*]]$
\end{theorem}

\begin{theorem}[Subsumption of Polymorphic Subtyping]
    If $\Gamma \vdash A \le B$, then $\lift{\Gamma} \vdash \lift{A} \le \lift{B} : [[*]]$
\end{theorem}

The proof is straightforward by making use of the \emph{Well-formedness} lemma
in Odersky and L\"aufer system, mentioned in section \ref{sec:adaptation}, to conclude that
$A$ itself is a well-formed type in $\Gamma \vdash A \le \forall x.\, B$, and
$\forall x. A$ is well-formed in $\Gamma \vdash \forall x. \, A \le B$.

% \bruno{The lemma that shows that the redundant premises are indeed redundant is not shown, right?
%   I think it should appear somewhere in Section 3.2.}

\bruno{After reading this section, I feel that the text in Section 3.1 should come in Section 2 instead.}
