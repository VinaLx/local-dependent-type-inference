\section{The Metatheory of \name}

In this section, we introduce the design choices of \name to handle to challenge
brought by the dependent generalization of DK's declarative subtyping rules.
We also present the desired properties for \name to hold, which contribute to
the proof of transitivity and type safety.

Transitivity of subtyping is a general challenge for dependent type systems due
to the mutual dependency of typing and subtyping. Thankfully the Unified Subtyping
combines the two so there is only one judgement to reason about. Although
significantly simplified in one aspect, the DK's style subtyping brings new issues
on the table.

Although we have imposed restrictions on the implicit instantiation, they do not
change the indeterministic and non-type-preserving nature of the direct operational
semantics, due to not having access to typing information in the dynamic semantics.
So we choose a indirect path to show the type safety of \name.

And finally we expect the subtyping relation of \name to subsume the DK's
declarative subtyping.

\subsection{the Adaptation of DK-Style Subtyping}

DK's declarative subtyping features the following two rules:

\begin{mathpar}
    \inferrule*[lab=$\le\forall L$]
      {\Gamma \vdash \tau \\ \Gamma \vdash [\tau / x]\, A \le B}
      {\Gamma \vdash \forall x.\, A \le B}
    \and
    \inferrule*[lab=$\le\forall R$]
      {\Gamma ,\, x \vdash A \le B}
      {\Gamma \vdash A \le \forall x.\, B}
\end{mathpar}

In order for the \emph{Well-formedness}\cite{dunfield2013lemmas} property
(\emph{If $\Gamma \vdash A \le B$, then $\Gamma \vdash A$ and $\Gamma \vdash B$})
to hold in DK's system, these two rules relies on certain properties that
potentially do not hold in our generalization. We make several adjustments
in our adaptation to combat these issues.

\subsubsection{Reverse Substitution of Well-formedness}

Rule $\le\forall L$ relies on the ``Reverse Substitution'' property, which is:
\emph{If $\Gamma \vdash [B / x] \, A$ and $\Gamma \vdash B$, then $\Gamma,\, x \vdash A$}.
The generalization we care about is:
\emph{If $[[G |- [B / x] A : *]]$ and $[[G |- B : C]]$, then $[[G , x : C |- A : *]]$}.
Since in a dependently-typed setting, the values of expressions also matter during typing
besides the types of expressions, a counter-example of the property could be:

\begin{align*}
& F : [[int]] \rightarrow [[*]],\, a : F~42 \vdash (\lambda y : F~\rulehl{42}.\, [[int]]) ~ a : [[*]] \\
& F : [[int]] \rightarrow [[*]],\, a : F~42\rulehl{,\, x : [[int]]} \vdash (\lambda y : F~\rulehl{x}.\, [[int]]) ~ a : [[*]]
\end{align*}

We cannot ``reverse substitute'' the $42$ in the type annotation to a variable
of same type, while the application expression depends specifically on the value
$42$ in order for the type of argument $a$ to match the parameter type.
So we add a premise $[[G , x : A |- B : *]]$ in \rref{s-forall-l} to directly
ensure the well-formedness of types in the conclusion.

\subsubsection{Strengthening of Contexts}

Rule $\le\forall R$ however, relies on a simpler-looking lemma:
\emph{if $\Gamma,\, x \vdash A$ and $x ~\text{is fresh in}~ A$, then $\Gamma \vdash A$}, which
is trivial to prove. However its generalization:
\emph{if $[[G, x : B |- A : *]]$ and $x ~\text{is fresh in}~ A$},
is a much more difficult problem since we are no longer reasoning about
``well-formedness'' but also typing and subtyping. In our system the property
does not hold without the help of diverging programs with fixpoint operator,
we will come back to this issue in the discussion section.

But for now, we add a premise $[[G |- A : *]]$ to \rref{s-forall-r},
requiring $A$ to be a well-typed type without the help of the fresh variable.
A consequence of adding this premise is that we will encounter a circular proof
while trying to prove $[[G |- forall x : A. B <: forall x : A . B : *]]$ for
arbitrary $A$ and $B$ by first applying \rref{s-forall-r}. We resolve this issue by
adding \rref{s-forall}.

\subsection{Typing Properties of \name}

With our rules properly set up, most of the properties are not difficult to
prove in terms of techniques. We introduce \emph{Reflexivity}, \emph{Weakening},
\emph{Context Narrowing}, \emph{Substitution} and \emph{Type Correctness}
in this section.

\begin{theorem}[Reflexivity]
   If $[[G |- e1 <: e2 : A]]$,
   then $[[G |- e1 : A]]$ and $[[G |- e2 : A]]$.
\end{theorem}

Usually a subtyping relation is reflexive when any well-formed type is a subtype
of itself. With Unified Subtyping, the well-formedness of types is expressed by
subtyping relation as well, so the reflexivity looks more like the generalization
of \emph{Well-formedness} mentioned in the previous section. \emph{Reflexivity}
breaks down into two parts, \emph{Left Reflexivity} and \emph{Right Reflexivity}.

\begin{lemma}[Left Reflexivity]
   If $[[G |- e1 <: e2 : A]]$,
   then $[[G |- e1 : A]]$.
\end{lemma}

\begin{lemma}[Right Reflexivity]
   If $[[G |- e1 <: e2 : A]]$,
   then $[[G |- e2 : A]]$.
\end{lemma}

Both of the branches are proved by induction on the derivation of
$[[G |- e1 <: e2 : A]]$.
Left reflexivity and right reflexivity when derivations end with \rref{s-forall-l}
and \rref{s-forall-r} respectively are directly solved by \rref{s-forall}.

\begin{theorem}[Weakening]
    If $[[G1 ,, G3 |- e1 <: e2 : A]]$ and $[[|- G1 ,, G2 ,, G3]]$,
    then $[[G1 ,, G2 ,, G3 |- e1 <: e2 : A]]$.
\end{theorem}

\emph{Weakening} is proved by induction on the derivation of
$[[G1 ,, G3 |- e1 <: e2 : A]]$. The redundant premises discussed in section
\ref{sec:type-system} help simplify the proof, by creating the induction
hypotheses about the type annotation of various expressions. Otherwise we are
not able to prove $[[|- G1 ,, G2 ,, G3 , x : A]]$ given only
$[[|- G1 ,, G3 , x : A]]$ and no help from induction hypotheses.

\begin{theorem}[Context Narrowing]
\label{thm:narrowing}
    If $[[G1 , x : B ,, G2 |- e1 <: e2 : C]]$ and $[[G1 |- A <: B : k]]$,
    then $[[G1 , x : A ,, G2 |- e1 <: e2 : C]]$.
\end{theorem}

\begin{lemma}[Well-formedness of Narrowing Context]
\label{thm:wf-narrowing}
   If $[[|- G1 , x : B ,, G2]]$ and $[[G1 |- A <: B : k]]$,
   then $[[|- G1 , x : A ,, G2]]$.
\end{lemma}

Theorem \ref{thm:narrowing} and lemma \ref{thm:wf-narrowing} are proved by
mutual induction on the derivations of $[[G1 , x : B ,, G2 |- e1 <: e2 : C]]$
and $[[|- G1 , x : B ,, G2]]$. \Rref{s-var} is the only non-trivial case to
solve, which relies on \emph{Weakening} to conclude
$[[G1 , x : A ,, G2 |- A <: B : k]]$ from $[[G1 |- A <: B : k]]$, in order to
derive $[[G1 , x : A ,, G2 |- x : B]]$ through \rref{s-sub}.

\begin{theorem}[Substitution]
    If $[[G1 , x : A ,, G2 |- e1 <: e2 : B]]$ and $[[G1 |- t : A]]$,
    then $[[G1 ,, [t / x] G2 |- [t / x] e1 <: [t / x] e2 : [t / x] B ]]$.
\end{theorem}

Notably \emph{Substitution} imposes mono-expression restriction on the expression
being substituted with, which comes at a result of restricting the instantiation
of polymorphic parameter to only mono-expressions in \rref{s-forall-l}.

Take following derivation as an example:

\begin{mathpar}
    \inferrule*[Right=s-forall-l]
      {A : [[*]],\, F: A \rightarrow [[*]]\rulehl{,\, a : A} \vdash [\rulehl{a} / x]\, F ~ x \le F~\rulehl{a} : [[*]]}
      {A : [[*]],\, F: A \rightarrow [[*]]\rulehl{,\, a : A} \vdash \forall x : A.\, F ~ x \le F~\rulehl{a} : [[*]]}
\end{mathpar}

Assuming we have not put mono-expr restrictions on \emph{Substitution}
and \rref{s-app}. If we substitute $a$ with an arbitrary poly-expression, the
derivation stop working because \rref{s-forall-l} requires a mono-expr
instantiation and \rref{s-app} requires the argument of both sides to be
syntactically the same.

Worth mentioning, while the poly-expr breaks the subtyping aspect of the
\emph{Substitution}, a ``typing'' version of it
(If $[[G1 , x : A ,, G2 |- e : B]]$ and $[[G1 |- e1 : A]]$,
then $[[G1 ,, [e1 / x] G2 |- [e1 / x] e : [e1 / x] B]]$) does not escape the issue above.
Because in dependently-typed languages, substitutions involve in the types of
expressions as well. And due to the presence of \rref{s-sub}, we still have to
maintain the potential subtyping relation of the types of expressions after substitution,
for example:

\begin{mathpar}
    \inferrule*[Right=s-sub]
      {A : [[*]],\, F: A \rightarrow [[*]],\, a : A,\, b : \forall x : A.\, F~x \vdash b : \rulehl{\forall x : A.\, F~x}}
      {A : [[*]],\, F: A \rightarrow [[*]],\, a : A,\, b : \forall x : A.\, F~x \vdash b : \rulehl{F ~ a}}
\end{mathpar}

As a result, we put mono-expr restriction on \emph{Substitution} theorem,
as well as the typing rules involving expressions that potentially ``trigger''
substitutions during reductions, including the arguments of applications and the
fixpoint expressions.

\begin{lemma}[Context Well-formedness of Substitution]
\label{thm:wf-substitution}
   If $[[|- G1 , x : A  ,, G2]]$ and $[[G1 |- t : A]]$,
   then $[[|- G1 ,, [t / x] G2]]$.
\end{lemma}

After understanding the mono-expr restriction on \emph{Substitution}, the actual
proof is not complicated, which proceeds with the mutual induction with
lemma \ref{thm:wf-substitution} on the derivations of
$[[G1 , x : A ,, G2 |- e1 <: e2 : B]]$ and $[[|- G1 , x : A ,, G2]]$. When the
derivation ends with \rref{castup,castdn}, the proof
requires the reduction relation to preserve after the substitution.
This property should usually hold, but puts an interesting constraint which we
have to consider when designing the reduction rules (see discussion section).

\begin{lemma}[Reduction Substitution]
   If $[[A --> B]]$, then $[[ [t / x] A --> [t / x] B ]]$
\end{lemma}

\begin{theorem}[Type Correctness]
    If $[[G |- e1 <: e2 : A]]$,
    then $\exists k.\, [[G |- A : k]]$ or $A = [[box]]$.
\end{theorem}

\emph{Type Correctness} is a nice property that ensures
what appear in the position of a type are actually types.
The theorem is proved by induction on the derivation of $[[G |- e1 <: e2 : A]]$,
the only non-trivial case is when the derivation ends with \rref{s-app}. We make
use of \emph{Substitution} and the inductive hypothesis to demonstrate the head
of $\Pi$ type preserve its kind after the argument is applied.

\subsection{Transitivity}

Usually \emph{Transitivity} in a dependently-typed subtyping system is axiomized
in the declarative system.
Then a process is went through called the ``transitivity elimination'', which proves
the admissibility of transitivity in the declarative systems with the help of
their algorithmic version \cite{hutchins2010pure}\cite{aspinall1996subtyping}.
However Unified Subtyping help us simplify the process and prove the
transitivity directly\cite{yang2017unifying}. We prove the generalized
version of transitivity with the types of premises being potentially
syntactically different. Then the ``restricted'' version of transitivity follows directly.

\begin{theorem}[Generalized Transitivity]
    If $[[G |- e1 <: e2 : A]]$ and $[[G |- e2 <: e3 : B]]$,
    then $[[G |- e1 <: e3 : A]]$.
\end{theorem}

\subsubsection{The Uniqueness of Kind} Assuming the derivation of the second
premise ends with \rref{s-forall-r}, then we roughly faces the following problem:

\begin{mathpar}
    \inferrule*[]
      {[[G |- e1 <: e2 : A]] \\ [[G, x : B |- e2 <: C : *]]}
      {[[G |- e1 <: forall x : B. C : A]]}
\end{mathpar}

Before applying \rref{s-forall-r} to the conclusion, we have to establish the relationship
between $A$ and $[[*]]$. Were there no restrictions on the kinding of $\forall$ types,
this would be much more complicated situation, where the reasoning of kinding,
such as inversion lemmas of about kinds, and transitivity depend on each other.
This is one of the main reasons why we forbid $\forall$ types having kind $[[box]]$.
Then we have the following nice theorem:

\begin{theorem}[Kind Uniqueness]
    If $[[G |- e : k]]$ and $[[G |- e : A]]$,
    then $A = k$.
\end{theorem}

The proof is led by generalizing the shape of $k$ to be
$\Pi x : A.\, \dots \Pi x : B.\, \dots k$ to generate useful inductive hypotheses
when the derivation of $[[G |- e : k]]$ ends with \rref{s-app}. Then the proof
proceeds with induction on the derivation of the generalized $[[G |- e : k]]$ and
assembling various lemmas of kinding to solve different cases.

With the help of \emph{Kind Uniqueness},
we ensure the equivalence of $A$ and $[[*]]$ on this and other similar situations.

\subsubsection{The Induction}

\emph{Generalized Transitivity} is proved by induction on the 3-tuple:

$$
\langle \#\forall([[e1]]) + \#\forall([[e2]]) + \#\forall([[e3]]), ~
\mathbf{size}([[e1]]) + \mathbf{size}([[e3]]), ~
\mathcal{D}_1 + \mathcal{D}_2 \rangle
$$

where $\#\forall$ counts the number of $\forall$s in the expression, $\mathbf{size}$ measures
the size of the syntax tree of the expression, $\mathcal{D}_1$ and $\mathcal{D}_2$ denote
the sizes of the derivation trees of the first and the second premises respectively. The proof
is mainly motivated by DK's transitivity proof of their subtyping system of
induction on the pair of $\langle \#\forall(e2) ,~ \mathcal{D}_1 + \mathcal{D}_2 \rangle$\cite{dunfield2013lemmas},
with adjustments to fit in our system.

The most problematic case to solve is when the first premise ends with \rref{s-forall-r},
and the second ends with \rref{s-forall-l}, essentially we have to show the following:

\begin{mathpar}
    \inferrule*[]
      {[[G , x : A |- e1 <: B : *]] \\ [[G |- [t / x] B <: e3 : *]]}
      {[[G |- e1 <: e3 : *]]}
\end{mathpar}

Here the only decreasing measure we can rely on is the fact that
$\#\forall([[ [t / x] B ]])$ is one less than $\#\forall([[forall x : A. B]])$.
And then this case is solved by applying the inductive hypothesis after performing
substitution on the premise $[[G , x : A |- e1 <: B : *]]$ using the fact that
$x$ does not occur in $e1$, obtaining $[[G |- e1 <: [t / x] B : *]]$.

The reason why we cannot directly copy DK's proof measure is because of the case
when both premises end with \rref{s-pi}, where we encounter the following problem:

\begin{mathpar}
    \inferrule*[]
      {[[G , x : A2 |- B1 <: B2 : k]] \\ [[G , x : A3 |- B2 <: B3 : k]] \\ [[G |- A3 <: A2 : k2]]}
      {[[G , x : A3 |- B1 <: B3 : k]]}
\end{mathpar}

The first and the second premise above do not share the same context, so they
must be unified with the help of \emph{Context Narrowing}.
However \emph{Context Narrowing} changes the size of derivation tree, so we are
not able to use the inductive hypothesis of $\mathcal{D}_1 + \mathcal{D}_2$.

And finally we have to make adjustments to solve the cases which preserve the
size of derivation tree, but not the sizes of the expressions.
Such scenario occurs when the first premise ends with \rref{s-forall-l},
where we face the following problem:

\begin{mathpar}
    \inferrule*[]
      {[[G |- [t / x] B <: e2 : *]] \\ [[G |- e2 <: e3 : C]]}
      {[[G |- forall x : A. B <: e3 : *]]}
\end{mathpar}

In this case $\#\forall({[[ [t / x] B]]})$ is one less than $\#\forall([[forall x : A. B]])$,
so it can be solved by applying \rref{s-forall-l} and the inductive hypothesis of $\#\forall(e_1)$.
And $\#\forall(e_3)$ is added to make the mesure ``symmetric''
to deal with the contravariance case of \rref{s-pi}.

Finally, although most of the cases without the involvement of $\forall$ can be
solved with the help of the inductive hypothesis of
$\mathbf{size}(e_1) + \mathbf{size}(e_3)$. $\mathcal{D}_1 + \mathcal{D}_2$ solves
the cases where either premise ends with \rref{r-sub}, where the only decreasing
measure is the size of the derivation trees.

\begin{corollary}[Transitivity]
    If $[[G |- e1 <: e2 : A]]$ and $[[G |- e2 <: e3 : A]]$,
    then $[[G |- e1 <: e3 : A]]$.
\end{corollary}

\emph{Transitivity} is a special case of
\emph{Generalized Transitivity} where $A = B$.

\subsection{Type Safety}

Since the reduction rules of \name do not have access to typing information, it
cannot perform valid instantiation of the implicit arguments during application,
leaving the runtime semantics indeterministic and potentially non-type-preserving.
We tackle this issue by trying to make the choice of implicit instantiation
irrelevant at runtime with the restrictions on the introduction
rule of $\forall$ types (\rref{s-bind}). We define a ``extraction'' function
that eliminates all the type annotations in the terms
($\lambda$, $\Lambda$, $mu$ and $\castup$),
and keep the implicit parameter from occuring in the extracted expressions.
This way the choices of implicit instantiation only affect the type annotation,
which should not be relevant for runtime computation.

\begin{figure}
  \centering
  \begin{equation*}
  \begin{array}{lcl}
      \text{Extracted Value} ~ ev & ~ \Coloneqq ~ & [[k]] \mid [[n]] \mid [[int]] \mid [[elambda x. ee]] \mid [[epi x : eA. eB]] \mid [[ebind x. ee]] \\
      & \mid & [[eforall x : eA. eB]] \mid [[ecastup ee]]
  \end{array}
  \end{equation*}
  \drules[er]{$[[ee1 *--> ee2]]$}{Extracted Semantics}
    {app,beta,elim,mu,castdn,castXXinst,castXXelim}
  \label{fig:extract-semantics}
  \caption{Operational Semantics for Extracted Expressions}
\end{figure}

In this section, we discuss the type safety of \name in the sense that,
if an expression is well-typed in \name, then the reduction of its extraction
does not ``go wrong''. Figure \ref{fig:extract-semantics} shows the semantics of
extracted expression. The extracted semantics mostly mirrors the semantics
shown in figure \ref{fig:semantics}, except for \rref{er-elim,er-cast-elim}, which
conveys the idea of irrelevance of implicit instantiation by eliminating the
parameter directly.

\subsubsection{Progress} We show the \emph{Progress} property in both unextracted
and extracted expressions.

\begin{theorem}[Progress]
    If $[[nil |- e : A]]$,
    then $\exists \, e'. \, e \longrightarrow e'$ or $e$ is a value.
\end{theorem}

\begin{theorem}[Extracted Progress]
    If $[[nil |- e : A]]$,
    then $\exists \, e'. \, \extract{e} \longleftarrow_E e'$ or $\extract{e}$ is an extracted value.
\end{theorem}

Both theorems are proved by induction on the derivation of $[[nil |- e : A]]$,
the proof is mostly straightforward except for when the derivation ends with $\castdn$.
We use the fact that, for a well-typed expression whose type can reduce, that expression
cannot be a value unless it is a $\castup$ or $\Lambda$ expression.

\begin{lemma}[Reducible Type]
    If $[[G |- e : A]]$, $[[A --> B]]$ and $e$ is not $\castup$ or $\Lambda$ expressions,
    then $e$ is not a value.
\end{lemma}

This lemma is also useful for the proof of \emph{Extracted Progress} since the
value definitions are very similar.

\begin{lemma}[Extracted Value to Value]
    If $\extract{e}$ is an extracted value, then $e$ is a value.
\end{lemma}

\begin{lemma}[Value to Extracted Value]
    If $e$ is a value, then $\extract{e}$ is an extracted value.
\end{lemma}

\subsubsection{Preservation}

In this section we discuss the preservation theorem tailored by \name.
Since the direct operational semantics is not generally type-preserving and
deterministic because of the implicit instantiations, we show the
``preservation'' the help of the extracted expressions where implicit parameters
do not matter to the computation. For other reduction rules that do not involve
such issues, we discuss them as though we are proving a normal preservation
for brevity.

\begin{theorem}[Extracted Subtype Preservation]
    If $[[G |- e1 <: e2 : A]]$, $\extract{e_1} \longrightarrow_E E_1'$ and $\extract{e_2} \longrightarrow_E E_2'$,
    then $\exists\,e_1' \, e_2'.$ $\extract{e_1'} = E_1'$, $\extract{e_2'} = E_2'$, $e_1 \longrightarrow e_1'$, $e_2 \longrightarrow e_2'$ and $\Gamma \vdash e_1' \le e_2' : A$.
\end{theorem}

\begin{figure}
    \centering
    \begin{tikzcd}[row sep=large, column sep=large]
        e : A \arrow[r] \arrow[dashed]{d}[swap]{\text{Extraction}} & e' : A \\
        E \arrow[shorten=1mm]{r}[swap, pos=1]{E} & E' \arrow[dashed]{u}[swap]{\text{Annotation}}
    \end{tikzcd}
    \caption{Diagram for Extracted Preservation without Subtyping}
    \label{fig:preservation}
\end{figure}

Figure \ref{fig:preservation} shows the idea of our preservation lemma without
the subtyping. Here we use ``annotation'' as the reverse process of extraction.
If an expression ($e$) is well-typed, and its extraction ($E$)
reduces to another extracted expression ($E'$), we can find a ``annotated''
expression of $E'$ ($e'$) that is reduced by $e$ and also preserves the type $A$.
When no implicit instantiation happens in the reduction, then $e \longrightarrow e'$
is deterministic, it is just a normal type preservation. When there is an implicit
instantiation, if the extracted expression can reduce, we show that there must
be an valid instantiation for $e$ for preserve its type after the reduction, and
this instantiation only affect the type annotation.

Put it in another way, the runtime semantics of \name can be implemented only in
extracted expressions, when its annotation is well-typed.
Because for every step it reduces, we can find a corresponding annotation that
preserve the type of, and have the reduction relation with the
annotation of its expansion.

The theorem is proved by induction on the derivation of $[[G |- e1 <: e2 : A]]$,
cases for \rref{r-beta,r-mu} are solved with the substitution theorem,
cases \rref{r-app,r-castdn} are solved by inductive hypothesis. The interesting
ones are cases for \rref{r-cast-elim} and the implicit instantiation
(\rref{r-inst,r-cast-inst}).

\paragraph{Subtype Preservation for Types} The problem of cast elimination
can be demonstrated by the following derivation:

\begin{mathpar}
    \hspace{-1.5cm}
    \inferrule*[Right=s-castdn]
      {\rulehl{[[B1 --> B2]]} \\ \inferrule*[Right=s-sub]
        {\rulehl{[[G |- A1 <: B1 : k]]} \\ \inferrule*[Right=s-castup]
          {\rulehl{[[A1 --> A2]]} \\ [[G]] \vdash [[e]] : \rulehl{A_2}}
          {[[G |- castup [A1] e : A1]]}}
        {[[G |- castup [A1] e : B1]]}}
      {[[G]] \vdash [[castdn castup [A1] e]] : \rulehl{B_2}}
\end{mathpar}

Here when the typing of the inner $\castdn$ does not directly follow
\rref{r-castup}, but the subsumption rule instead. We have to show that after
the cast elimination, expression $e$ has type $B_2$, which means $A_2$ must be
a subtype of $B_2$. While $[[A1 --> A2]]$, $[[B1 --> B2]]$ and $A_1$ is a subtype
of $A_2$, this case depends back on the subtyping preservation we currently attempt to prove
. This problem was also observed by the previous work on Unified Subtyping
with the cast operators\cite{yang2017unifying}. Unfortunately they solved this
situation with the help of a lemma that does not hold in our system.

We tackle this problem from another direction, with the observation that the
demand for subtyping preservation shifts from the ``terms'' to the ``types''.
With the CoC-like kind hierarchy, we have only limited layers in the of types.
In fact, we only need to go down one layer in the type hierarchy to be able to
obtain subtype preservation directly, since there is no subtyping involved at kind level,
hence no problem for the cast elimination there.

Even better, we show that by going down one level in the type hierarchy, the options
for the reduction that can be performed by a well-typed term are very limited.
Implicit abstractions does not occur in type computation due to the kind
restriction of $forall$ types. Cast operator also does not occur in type computation,
since we prove that well-typed reduction never occur at kind level.

\begin{figure}
    \drules[dr]{$[[A1 ==> A2]]$}{Deterministic Reduction}
      {app,beta,mu}
    \caption{Deterministic Reduction in the Cast}
    \label{fig:deterministic-reduction}
\end{figure}

Figure \ref{fig:deterministic-reduction} shows the effective reduction rules
inside cast operators.

\begin{lemma}[Deterministic Reduction]
    If $[[A ==> A1]]$ and $[[A ==> A2]]$,
    then $A_1 = A_2$.
\end{lemma}

\begin{lemma}[Deterministic Type Reduction]
    If $[[G |- A1 : k]]$ and $[[A1 --> A2]]$,
    then $[[A1 ==> A2]]$.
\end{lemma}

The cases for implicit abstractions are easy to prove. For the cast operators
we have the following lemma.

\begin{lemma}[Expressions of $[[box]]$ Never be Reduced]
    If $[[A --> B]]$ and $[[G |- e : A]]$,
    then $B$ does not have type $[[box]]$.
\end{lemma}

And then the subtype preservation of type computation can be easily shown.

\begin{lemma}[Subtype Preservation for Types]
    If $[[G |- A1 <: B1 : k]]$, $[[A1 ==> A2]]$ and $[[B1 ==> B2]]$,
    then $[[G |- A2 <: B2 : k]]$.
\end{lemma}

\paragraph{Implicit Instantiations}

The proof of two cases for implicit instantiations (\rref{r-inst,r-cast-inst})
are quite similar. They both makes use of the observation that, the implicit
instantiations are only triggered by \rref{s-forall-l}, which is exactly where
polymorphic types are instantiated. The implicit arguments are the
mono-expressions that instantiate the polymorphic types. And the result types of the
implicit instantiations are exactly the instantiation of the polymorphic types.
And then the rest of the proofs are finished by standard inversion lemmas,
with the help of \emph{Substitution} for the instantiation.

\subsection{Subsumption of DK's Subtyping}
