\section{The Metatheory of \name}
\label{sec:metatheory}

This section presents the metatheory of \name, and discusses several challenges
that arose in the design of the rules to ensure the desired properties.

The three main results of the metatheory are:
\emph{transitivity of unified subtyping}, \emph{type-soundness} and
\emph{completeness with respect to Odersky and L\"aufer's} polymorphic
subtyping. Transitivity of subtyping is a general challenge for dependent type systems due
to the mutual dependency of typing and subtyping, and the Odersky and L\"aufer style
subtyping brings new issues to the table. For type-soundness, the key challenge
is the non-deterministic and non-type-preserving nature of the reduction relation.
To address this issue, we employ a type soundness proof technique
that uses the erased reduction relation shown in Figure~\ref{fig:extraction}.
% \bruno{Check that the completeness lemma with respect to DK is discussed, and that the lemma
% that shows that redundant premises are indeed redundant are discussed as well.}


\begin{comment}
In this section, we introduce the design choices of \name to handle to challenge
brought by the dependent generalization of DK's declarative subtyping rules.
We also present the desired properties for \name to hold, which contribute to
the proof of transitivity and type safety.

Transitivity of subtyping is a general challenge for dependent type systems due
to the mutual dependency of typing and subtyping. Thankfully the Unified Subtyping
combines the two so there is only one judgment to reason about. Although
significantly simplified in one aspect, the DK's style subtyping brings new issues
to the table.

Although we have imposed restrictions on the implicit instantiation, they do not
change the indeterministic and non-type-preserving nature of the direct operational
semantics, due to not having access to typing information in the dynamic semantics.
So we choose an indirect path to show the type safety of \name.

And finally, we expect the subtyping relation of \name to subsume the DK's
declarative subtyping.
\end{comment}

\subsection{Polymorphic Subtyping in a Dependently Typed Setting}
\label{sec:adaptation}
% \bruno{I'm not entirely sure if this text belongs here or in a previous section.}

The polymorphic subtyping relation by Odersky and L\"aufer features the following two rules:
\begin{mathpar}
    \inferrule*[right=$\forallL$]
      {\Gamma \vdash \tau \\ \Gamma \vdash [\tau / x]\, A \le B}
      {\Gamma \vdash \forall x.\, A \le B}
    \and
    \inferrule*[right=$\forallR$]
      {\Gamma ,\, x \vdash A \le B}
      {\Gamma \vdash A \le \forall x.\, B}
\end{mathpar}
In order for the \emph{well-formedness}~\cite{dunfield2013lemmas} property
(\emph{If $\Gamma \vdash A \le B$, then $\Gamma \vdash A$ and $\Gamma \vdash B$})
to hold in L\"aufer and Odersky's system, these two rules rely on certain properties
that do not hold in our dependently typed generalization. So we make several adjustments
in our adaptation to combat these issues, which result in the difference between
our current system and a direct generalization.

\subsubsection{Reverse Substitution of Well-Formedness.}
Rule $\forallL$ relies on the \emph{reverse substitution} property, but this property
does not hold in a dependently typed setting. Thus we need an alternative design that
still ensures well-formedness, but without relying on the reverse substitution property.

The reverse substitution property is:
\emph{If $\Gamma \vdash [B / x] \, A$ and $\Gamma \vdash B$, then $\Gamma,\, x \vdash A$}.
That is if we have a type $A$ with all occurrences of $x$ substituted by $B$ and $B$
is well-formed we can conclude that $A$ is well-formed under $\Gamma,\, x$.
A possible generalization of this property in a dependently typed setting would be:
\emph{If $[[G |- [B / x] A : *]]$ and $[[G |- B : C]]$, then $[[G , x : C |- A : *]]$}.
Since in a dependently-typed setting, the values of expressions also matter during typing
besides the types of expressions, a counter-example of the property is:
\begin{align*}
& F : [[int]] \rightarrow [[*]],\, a : F~42  \vdash (\lambda y : F~\rulehl{42}.\, [[int]]) ~ a : [[*]] \\
& F : [[int]] \rightarrow [[*]],\, a : F~42  \rulehl{,\, x : [[int]]} \vdash (\lambda y : F~\rulehl{x}.\, [[int]]) ~ a : [[*]]
\end{align*}
We cannot ``reverse substitute'' the $42$ in the type annotation to a variable
of the same type: the application expression depends specifically on the value
$42$ in order for the type of argument $a$ to match the parameter type.
So we add a premise $[[G , x : A |- B : *]]$ in \rref{s-forall-l} to directly
ensure the well-formedness of types in the conclusion.

\subsubsection{Strengthening of Contexts.}
% \bruno{As far as I understand the discussion here + in Section 4.1 the strenghtening
%   lemma does not hold even when considering that fixpoints are added to the language.
%   Thus I think you should just show a counter-example here, avoid mentioning fixpoints
%   at this point, and mention only fixpoints in Section~\ref{sec:instantiation}. Please rewrite
% accordingly.}

Rule $\forallR$ relies on a strenghtening lemma:
\emph{if $\Gamma,\, x \vdash A$ and $x ~\text{is fresh in}~ A$, then $\Gamma \vdash A$}, which
is trivial to prove.
However its generalization:
\emph{if $[[G, x : B |- A : *]]$ and $x ~\text{is fresh in}~ A$, then $[[G |- A : *]]$},
does not hold in our system. We can construct the following example:
\begin{equation*}
    F : [[int]] \rightarrow [[*]],\, A : [[*]],\, \rulehl{a : A} \vdash F ~ ([[(bind x : A. lambda y : int. y)]]~ 42) : [[*]]
\end{equation*}
The variable $a$ does not appear in any expression, but plays a
crucial role when considering the subtyping relation $\Gamma \vdash \forall x : A.\, [[int]] \rightarrow [[int]] \le [[int]] \rightarrow [[int]]$.
In this case, we cannot apply \rref{s-forall-l} while we are not able to find a
well-typed instance for the polymorphic parameter, so the variable in the context
is needed even though it does not occur anywhere.
%Note that although in this
%case we could pick a diverging program $\mu x : A.\, x$ as an instance. But
%since we require fixpoint to be mono-expression to be well-typed, the workaround
%does not work if we replace $A$ with a polytype.

To counter the lack of strenghtening, we add a premise $[[G |- A : *]]$ to \rref{s-forall-r},
requiring $A$ to be a well-typed type without the help of the fresh variable.
A consequence of adding this premise is that we will encounter a circular proof
while trying to prove $[[G |- forall x : A. B <: forall x : A . B : *]]$ for
arbitrary $A$ and $B$ by first applying \rref{s-forall-r}. We resolve this issue by
adding \rref{s-forall}.

\subsection{Typing Properties of \name}

With our rules properly set up, we can prove most of the basic properties
using techniques borrowed form the \emph{unifed subtyping}~\cite{yang2017unifying} approach.
We introduce \emph{reflexivity}, \emph{weakening},
\emph{context narrowing}, \emph{substitution} and \emph{type correctness}
in this section.

\begin{theorem}[Reflexivity]
   If $[[G |- e1 <: e2 : A]]$,
   then $[[G |- e1 : A]]$ and $[[G |- e2 : A]]$.
\end{theorem}

Usually, a subtyping relation is reflexive when any well-formed type is a subtype
of itself. With unified subtyping, the well-formedness of types is expressed by
subtyping relation as well, so the reflexivity looks more like the generalization
of \emph{well-formedness} mentioned in the previous section. Reflexivity
breaks down into two parts, \emph{left reflexivity} and \emph{right reflexivity}.

\begin{lemma}[Left Reflexivity]
   If $[[G |- e1 <: e2 : A]]$,
   then $[[G |- e1 : A]]$.
\end{lemma}

\begin{lemma}[Right Reflexivity]
   If $[[G |- e1 <: e2 : A]]$,
   then $[[G |- e2 : A]]$.
\end{lemma}

\noindent Both of the branches are proved by induction on the derivation of
$[[G |- e1 <: e2 : A]]$.
Left reflexivity and right reflexivity when derivations end with \rref{s-forall-l}
and \rref{s-forall-r} respectively are directly solved by \rref{s-forall}.

\begin{theorem}[Weakening]
    If $[[G1 ,, G3 |- e1 <: e2 : A]]$ and $[[|- G1 ,, G2 ,, G3]]$,
    then $[[G1 ,, G2 ,, G3 |- e1 <: e2 : A]]$.
\end{theorem}

\noindent \emph{Weakening} is proved by induction on the derivation of
$[[G1 ,, G3 |- e1 <: e2 : A]]$. The redundant premises discussed in Section
\ref{sec:type-system} help simplify the proof, by creating the induction
hypotheses about the type annotation of various expressions. Otherwise, we are
not able to prove $[[|- G1 ,, G2 ,, G3 , x : A]]$ given only
$[[|- G1 ,, G3 , x : A]]$ and no help from induction hypotheses.

\begin{theorem}[Context Narrowing]
\label{thm:narrowing}
    If $[[G1 , x : B ,, G2 |- e1 <: e2 : C]]$ and $[[G1 |- A <: B : k]]$,
    then $[[G1 , x : A ,, G2 |- e1 <: e2 : C]]$.
\end{theorem}

\begin{lemma}[Well-formedness of Narrowing Context]
\label{thm:wf-narrowing}
   If $[[|- G1 , x : B ,, G2]]$ and $[[G1 |- A <: B : k]]$,
   then $[[|- G1 , x : A ,, G2]]$.
\end{lemma}

\noindent Theorem \ref{thm:narrowing} and Lemma \ref{thm:wf-narrowing} are proved by
mutual induction on the derivations of $[[G1 , x : B ,, G2 |- e1 <: e2 : C]]$
and $[[|- G1 , x : B ,, G2]]$. \Rref{s-var} is the only non-trivial case to
solve: it relies on \emph{weakening} to conclude
$[[G1 , x : A ,, G2 |- A <: B : k]]$ from $[[G1 |- A <: B : k]]$, in order to
derive $[[G1 , x : A ,, G2 |- x : B]]$ through \rref{s-sub}.

\begin{theorem}[Substitution]
    If $[[G1 , x : A ,, G2 |- e1 <: e2 : B]]$ and $[[G1 |- t : A]]$,
    then $[[G1 ,, [t / x] G2 |- [t / x] e1 <: [t / x] e2 : [t / x] B ]]$.
\end{theorem}

\noindent Notably \emph{substitution} imposes a mono-expression restriction on the expression
being substituted with, which comes at a result of restricting the instantiation
of polymorphic parameters to only mono-expressions in \rref{s-forall-l}.

Take following derivation as an example:

\begin{mathpar}
    \inferrule*[Right=s-forall-l]
      {A : [[*]],\, F: A \rightarrow [[*]]\rulehl{,\, a : A} \vdash [\rulehl{a} / x]\, F ~ x \le F~\rulehl{a} : [[*]]}
      {A : [[*]],\, F: A \rightarrow [[*]]\rulehl{,\, a : A} \vdash \forall x : A.\, F ~ x \le F~\rulehl{a} : [[*]]}
\end{mathpar}

\noindent Assuming that we have no mono-expression restrictions on \emph{substitution}
and \rref{s-app}. If we substitute $a$ with an arbitrary poly-expression, the
derivation stops working because \rref{s-forall-l} requires a mono-expression
instantiation and \rref{s-app} requires the argument of both sides to be
syntactically the same.

Worth mentioning is that while poly-expressions break the subtyping aspect of the
\emph{substitution}, a special case of the substitution theorem that discusses
the typing of one expression
(If $[[G1 , x : A ,, G2 |- e : B]]$ and $[[G1 |- e1 : A]]$,
then $[[G1 ,, [e1 / x] G2 |- [e1 / x] e : [e1 / x] B]]$)
does not hold for similar reasons.
% \bruno{Hummm is this text correctly
%   written? The way I read it is that both subtyping and typing aspects break the lemma, but I suppose
% that what you want to say is that one aspect breaks but the other does not. Please rephrase more carefully.}.
% \Alvin{Yup, the seemingly only-typing version of the substitution doesn't hold}
Because, in dependently-typed languages, substitutions are also involved in the types of
expressions as well. Due to the presence of \rref{s-sub}, we still have to
maintain the potential subtyping relation of the types of expressions after substitution,
for example:

\begin{mathpar}
    \inferrule*[Right=s-sub]
      {A : [[*]],\, F: A \rightarrow [[*]],\, a : A,\, b : \forall x : A.\, F~x \vdash b : \rulehl{\forall x : A.\, F~x}}
      {A : [[*]],\, F: A \rightarrow [[*]],\, a : A,\, b : \forall x : A.\, F~x \vdash b : \rulehl{F ~ a}}
\end{mathpar}

\noindent As a result, we put mono-expression restriction on the \emph{substitution} theorem,
as well as the typing rules involving expressions that potentially ``trigger''
substitutions during reductions, including the arguments of applications and the
fixpoint expressions.

\begin{lemma}[Context Well-formedness of Substitution]
\label{thm:wf-substitution}
   If $[[|- G1 , x : A  ,, G2]]$ and $[[G1 |- t : A]]$,
   then $[[|- G1 ,, [t / x] G2]]$.
\end{lemma}

\noindent After understanding the mono-expression restriction on \emph{substitution}, the actual
proof is not complicated: it proceeds by mutual induction with
Lemma \ref{thm:wf-substitution} on the derivations of
$[[G1 , x : A ,, G2 |- e1 <: e2 : B]]$ and $[[|- G1 , x : A ,, G2]]$. When the
derivation ends with \rref{castup,castdn}, the proof
requires the reduction relation to preserve after the substitution.
This property should usually hold, but puts an interesting constraint which we
have to consider when designing the reduction rules (see Section \ref{sec:cast-design}).

\begin{lemma}[Reduction Substitution]
   If $[[A --> B]]$, then $[[ [t / x] A --> [t / x] B ]]$
\end{lemma}

\begin{theorem}[Type Correctness]
    If $[[G |- e1 <: e2 : A]]$,
    then $\exists k.\, [[G |- A : k]]$ or $A = [[box]]$.
\end{theorem}

\noindent \emph{Type correctness} is a nice property that ensures that
what appears in the position of a type are actually types.
The theorem is proved by induction on the derivation of $[[G |- e1 <: e2 : A]]$,
the only non-trivial case is when the derivation ends with \rref{s-app}. We make
use of the substitution lemma and the inductive hypothesis to demonstrate the head
of $\Pi$ type preserve its kind after the argument is applied.

\subsection{Transitivity}
\label{sec:transitivity}

Transitivity is typically one of the most challenging properties to prove in
calculi with subtyping and it was also one of the harder proofs in \name.
The proof of transitivity requires a generalization of the usual transitivity
property:

\begin{theorem}[Generalized Transitivity]
    If $[[G |- e1 <: e2 : A]]$ and $[[G |- e2 <: e3 : B]]$,
    then $[[G |- e1 <: e3 : A]]$.
\end{theorem}

\noindent where the types of the premises are potentially different.
To prove this property we employ sizes for the inductive argument. Moreover we rely on
a subtle property of uniqueness of kinds.
\paragraph{Uniqueness of Kinds} Assuming that the derivation of the second
premise of generalized transitivity ends with \rref{s-forall-r}, then we face the following problem:
\begin{mathpar}
    \inferrule*[]
      {[[G |- e1 <: e2 : A]] \\ [[G, x : B |- e2 <: C : *]]}
      {[[G |- e1 <: forall x : B. C : A]]}
\end{mathpar}
\noindent Before applying \rref{s-forall-r} to the conclusion,
we have to establish the relationship between $A$ and $[[*]]$.
Were there no restrictions on the kinding of $\forall$ types,
this would be a much more complicated situation, where the inversion lemmas of
about kinds and transitivity depend on each other.
This is one of the main reasons why we forbid $\forall$ types having kind $[[box]]$.
Then we can have the following theorem:

\begin{theorem}[Kind Uniqueness]
    If $[[G |- e : k]]$ and $[[G |- e : A]]$,
    then $A = k$.
\end{theorem}

\noindent The proof is achieved by generalizing the shape of $k$ to be
$\Pi x : A.\, \dots \Pi x : B.\, \dots k$ for useful inductive hypotheses
when the derivation of $[[G |- e : k]]$ ends with \rref{s-app}. Then the proof
proceeds with induction on the derivation of the generalized $[[G |- e : k]]$ and
assembling various lemmas of kinding to solve different cases.

With the help of \emph{Kind Uniqueness},
we ensure the equivalence of $A$ and $[[*]]$ on this and other similar situations.

\paragraph{The Induction}

We prove \emph{Generalized Transitivity} by induction on the 4-tuple:

$$
\langle \#\forall([[e1]]) + \#\forall([[e2]]) + \#\forall([[e3]]), ~
\mathbf{size}([[e1]]) + \mathbf{size}([[e3]]), ~
\mathcal{D}_1 + \mathcal{D}_2 \rangle
$$

\noindent where $\#\forall$ counts the number of $\forall$s in the expression,
$\mathbf{size}$ measures the size of the syntax tree of the expressions,
$\mathcal{D}_1$ and $\mathcal{D}_2$ denote the sizes of the derivation trees of
the first and the second premises respectively.
The proof is mainly motivated by DK's transitivity proof of their subtyping
system of induction on the pair of
$\langle \#\forall(e2) ,~ \mathcal{D}_1 + \mathcal{D}_2 \rangle$~\cite{dunfield2013lemmas},
with adjustments to fit in our system.

The most problematic case to solve is when the first premise ends with \rref{s-forall-r},
and the second ends with \rref{s-forall-l}, essentially we have to show the following:

\begin{mathpar}
    \inferrule*[]
      {[[G , x : A |- e1 <: B : *]] \\ [[G |- [t / x] B <: e3 : *]]}
      {[[G |- e1 <: e3 : *]]}
\end{mathpar}

Here the only decreasing measure we can rely on is that
$\#\forall([[ [t / x] B ]])$ is one less than $\#\forall([[forall x : A. B]])$.
This case is solved by applying the inductive hypothesis after performing
substitution on the premise $[[G , x : A |- e1 <: B : *]]$ with the help of the fact that
$x$ does not occur in $e_1$, obtaining $[[G |- e1 <: [t / x] B : *]]$.

The reason why we cannot directly copy DK's proof measure is because of the case
when both premises end with \rref{s-pi}, where we encounter the following problem:
\begin{mathpar}
    \inferrule*[]
      {[[G , x : A2 |- B1 <: B2 : k]] \\ [[G , x : A3 |- B2 <: B3 : k]] \\ [[G |- A3 <: A2 : k2]]}
      {[[G , x : A3 |- B1 <: B3 : k]]}
\end{mathpar}
The first and the second premise above do not share the same context, which
must be unified with the context narrowing lemma.
However context narrowing changes the size of the derivation tree, so we are
not able to use the inductive hypothesis of $\mathcal{D}_1 + \mathcal{D}_2$.

We have to make adjustments to solve the cases which preserve the
size of derivation tree, but not the sizes of the expressions, which is
when the first premise ends with \rref{s-forall-l}:

\begin{mathpar}
    \inferrule*[]
      {[[G |- [t / x] B <: e2 : *]] \\ [[G |- e2 <: e3 : C]]}
      {[[G |- forall x : A. B <: e3 : *]]}
\end{mathpar}

\noindent In this case, $\#\forall({[[ [t / x] B]]})$ is one less than $\#\forall([[forall x : A. B]])$,
so it can be solved by applying \rref{s-forall-l} and the inductive hypothesis of $\#\forall(e_1)$.
And $\#\forall(e_3)$ is added to make the measure ``symmetric''
to deal with the contravariance case of \rref{s-pi}.

Finally, most of the cases that do not involve $\forall$ can be
solved with the help of the inductive hypothesis of
$\mathbf{size}(e_1) + \mathbf{size}(e_3)$. $\mathcal{D}_1 + \mathcal{D}_2$ solves
the cases where either premise ends with \rref{r-sub}, where the only decreasing
measure is the size of the derivation trees.

\begin{corollary}[Transitivity]
    If $[[G |- e1 <: e2 : A]]$ and $[[G |- e2 <: e3 : A]]$,
    then $[[G |- e1 <: e3 : A]]$.
\end{corollary}

\emph{Transitivity} is a special case of
\emph{Generalized Transitivity} where $A = B$.

\subsection{Type Safety}
\label{sec:type-safety}
% \bruno{You have been using the terminology extracted, whereas I think erased is more standard.
%   I've been trying to replace the terminology, but if you find more ``extracted'' occurrences, please
% replace those yourself.}

Since the reduction rules of \name do not have access to typing information, they
cannot perform valid instantiation checks of the implicit arguments during the application.
Thus, the runtime semantics is non-deterministic and potentially non-type-preserving.

We tackle this issue by making the choice of implicit instantiation
irrelevant at runtime with the restrictions in \rref{s-bind}.
We define an erasure function (shown in Figure \ref{fig:extraction})
% \bruno{This is the function that is shown earlier, right?
%   If so add a back reference to the figure here.}
that eliminates the type annotations
in some of the expressions ($\lambda$, $\Lambda$, $\mu$ and $\castup$),
and keep the implicit parameter from occurring in the erased expressions.
This way the choices of implicit instantiation only affect type annotations,
which are not relevant for runtime computation.

We show that \name is type-safe the sense that,
if an expression is well-typed, then the reduction of its erased version
does not ``go wrong''. Figure \ref{fig:extraction} shows the semantics of
erased expressions. The erasure semantics mostly mirrors the semantics
shown in Figure \ref{fig:semantics}, except for \rref{er-elim,er-cast-elim}, which
conveys the idea of the irrelevance of implicit instantiation by eliminating the
parameter directly.

\paragraph{Progress} We show the \emph{progress} property for both the original expressions
and erased expressions.

\begin{theorem}[Progress]
    If $[[nil |- e : A]]$,
    then $\exists \, e'. \, e \longrightarrow e'$ or $e$ is a value.
\end{theorem}

\begin{theorem}[Progress on erased expressions]
    If $[[nil |- e : A]]$,
    then $\exists \, E'. \, \extract{e} \longrightarrow_E E'$ or $\extract{e}$ is an erased value.
\end{theorem}
% \bruno{You mean a rightarrow above instead of a left arrow, right?}

\noindent Both theorems are proved by induction on the derivation of $[[nil |- e : A]]$.
The proof is mostly straightforward except when the derivation ends with $\castdn$.
We use the fact that, for a well-typed expression whose type can reduce, that expression
cannot be a value unless it is a $\castup$ or $\Lambda$ expression.

\begin{lemma}[Reducible Type]
    If $[[G |- e : A]]$, $[[A --> B]]$ and $e$ is not $\castup$ or $\Lambda$ expressions,
    then $e$ is not a value.
\end{lemma}

This lemma is also useful for the proof of progress for erased expressions, since the
value definitions are very similar.

\begin{lemma}[Erased Value to Value]
    If $\extract{e}$ is an erased value, then $e$ is a value.
\end{lemma}

\begin{lemma}[Value to Erased Value]
    If $e$ is a value, then $\extract{e}$ is an erased value.
\end{lemma}


\paragraph{Preservation}
%In this section we discuss the preservation theorem tailored by \name.
The direct operational semantics is not generally type-preserving and
deterministic because of the implicit instantiations. Thus, we show
preservation with the help of the erased expressions (where implicit parameters
do not matter to the computation). For other reduction rules that do not involve
such issues, we discuss them as though we are proving a normal preservation
for brevity.

\begin{theorem}[Subtype Preservation]
    If $[[G |- e1 <: e2 : A]]$, $\extract{e_1} \longrightarrow_E E_1'$ and $\extract{e_2} \longrightarrow_E E_2'$,
    then $\exists\,e_1' \, e_2'.$ $\extract{e_1'} = E_1'$, $\extract{e_2'} = E_2'$,
    $e_1 \longrightarrow e_1'$, $e_2 \longrightarrow e_2'$ and $\Gamma \vdash e_1' \le e_2' : A$.
\end{theorem}

\begin{figure}
    \centering
    \begin{tikzcd}[row sep=large, column sep=large]
        e : A \arrow[r] \arrow[dashed]{d}[swap]{\text{Erasure}} & e' : A \\
        E \arrow[shorten=1mm]{r}[swap, pos=1]{E} & E' \arrow[dashed]{u}[swap]{\text{Annotation}}
    \end{tikzcd}
    \caption{Diagram for Erased Preservation without Subtyping}
    \label{fig:preservation}
\end{figure}
% \bruno{In the diagram you use ``E'' to denote erased expressions, but earlier when you define
%   the syntax for erased expressions and in earlier texts you use ``e''. You should be
%   consistent and I think using ``E'' everywhere for erased expressions is best.}

\noindent The theorem might look a bit complicated at first glance, Figure
\ref{fig:preservation} shows the idea of our preservation lemma without
considering the subtyping aspect (assuming $[[G |- e : A]]$ instead of $[[G |- e1 <: e2 : A]]$).
% \bruno{Are you trying to show a simplified version of the lemma here?
% Is this actually valid, or you're just trying to give an overview of the idea?}.
% \Alvin{The figure only talks about preservation of typing, the lemma shows the
% preservation of subtyping, they both hold, but only typing is clearer}
Here we use \emph{annotation} as the reverse process of erasure.
If an expression ($e$) is well-typed, and its erasure ($E$)
reduces to another erased expression ($E'$), we can find a ``annotated''
expression of $E'$ ($e'$) that is reduced by $e$ and also preserves the type $A$.
When no implicit instantiation happens in the reduction, then $e \longrightarrow e'$
is deterministic: i.e. it is just normal type preservation. When there is implicit
instantiation, if the erased expression can reduce, we show that there must
exist a valid instantiation for $e$ that preserves its type after the reduction, and
this instantiation only affects type annotations.
In other words, the runtime semantics of \name can be implemented only with
erased expressions.
\begin{comment}
Because, for every reduction step, we can find a corresponding annotation that
preserves the type of, and have a reduction relation with the
annotation of its expansion.
\end{comment}

Aside from the erased aspect of our preservation lemma, we also consider a
generalized version of preservation in our unified subtyping system, the
\emph{subtype preservation}: reductions not only preserves the type of expression,
the subtyping relation between expressions is preserved as well.

The theorem is proved by induction on the derivation of $[[G |- e1 <: e2 : A]]$,
cases for \rref{r-beta,r-mu} are solved with the substitution theorem,
cases \rref{r-app,r-castdn} are solved by inductive hypothesis. The interesting
cases are \rref{r-cast-elim} and cases involving implicit instantiation
(\rref{r-inst,r-cast-inst}).

\paragraph{Cast Elimination}
The main issue of the cast elimination case can be demonstrated by the following derivation:
% \bruno{Do you mention this problem before to
%   start the paragraph with this text? What is the relationship between Subtype Preservation for Types
%   and cast elimination? You should connect these better, and also motivate why a separate lemma
% for Subtype preservation of types is needed. }

\begin{mathpar}
    \hspace{-1.5cm}
    \inferrule*[Right=s-castdn]
      {\rulehl{[[B1 --> B2]]} \\ \inferrule*[Right=s-sub]
        {\rulehl{[[G |- A1 <: B1 : k]]} \\ \inferrule*[Right=s-castup]
          {\rulehl{[[A1 --> A2]]} \\ [[G]] \vdash [[e]] : \rulehl{A_2}}
          {[[G |- castup [A1] e : A1]]}}
        {[[G |- castup [A1] e : B1]]}}
      {[[G]] \vdash [[castdn (castup [A1] e)]] : \rulehl{B_2}}
\end{mathpar}

Here the typing of the inner $\castdn$ does not directly follow
\rref{r-castup}, but the subsumption rule instead. We want to show that after
the cast elimination (following \rref{r-cast-elim}), expression $e$ has type $B_2$,
while in reality it has type $A_2$ (as highlighted).
Therefore want to show $\Gamma \vdash A_2 \le B_2$ with the information that
$\Gamma \vdash A_1 \le B_1$, $[[A1 --> A2]]$
and $[[B1 --> B2]]$ (which goes back to what we want to prove initially)
the subtype preservation after reduction, causes a circular dependency in the proof.
Subtype preservation needs to solve the cast elimination case, which depends back
on subtype preservation.
% \bruno{I don't follow this last sentence}.
This problem was also observed by the previous work on unified subtyping
with cast operators~\cite{yang2017unifying}. They solved this situation
by a delicate approach with the help of an essential lemma
\emph{Reduction Exists in the Middle} (If $[[G |- e1 <: e2 : A]]$, $[[G |- e2 <: e3 : A]]$
and $e_1 \longrightarrow e_1'$, $e_3 \longrightarrow e_3'$, there exists $e_2'$
such that $e_2 \longrightarrow e_2'$). Unfortunately this lemma does not hold
in our system since universal types, which are not reducible, can appear in the
middle of two reducible types, so we cannot adopt their proof.
% \bruno{What lemma? briefly explain.}

We tackle this problem from another direction, with the observation that the
demand for subtyping preservation shifts from the terms to the types.
With the CoC-like kind hierarchy, we have limited layers in types to traverse.
In fact, we only need to go down one layer in the type hierarchy to be able to
obtain subtype preservation directly,
since there is no subtyping involved at the kind level,
hence no problem for the cast elimination there.
Even better, we show that by going up one level in the type hierarchy
(only discussing the types of terms), the options
for the reduction that can be performed by a well-typed term are very limited.
% \bruno{Do you mean going down or going up? I would say that moving from term to type
% or from type to kind is moving up.}
Implicit abstractions do not occur in type computation due to the kind
restriction of universal types. We prove that well-typed reduction never occurs
at kind level, so cast operators also do not occur in type-level computation.

\begin{figure}
    \drules[dr]{$[[A1 ==> A2]]$}{Deterministic Reduction}
      {app,beta,mu}
    \caption{Deterministic Reduction.}
    \label{fig:deterministic-reduction}
\end{figure}

Figure \ref{fig:deterministic-reduction} shows the effective reduction rules
inside cast operators.

\begin{lemma}[Deterministic Reduction]
    If $[[A ==> A1]]$ and $[[A ==> A2]]$,
    then $A_1 = A_2$.
\end{lemma}

\begin{lemma}[Deterministic Type Reduction]
    If $[[G |- A1 : k]]$ and $[[A1 --> A2]]$,
    then $[[A1 ==> A2]]$.
\end{lemma}

The cases for implicit abstractions are easy to prove. For the cast operators
we have the following lemma.

\begin{lemma}[Expressions of kind $[[box]]$ are never reduced]
    If $[[A --> B]]$ and $[[G |- e : A]]$,
    then $B$ does not have type $[[box]]$.
\end{lemma}

And then the subtype preservation of type computation can be easily shown.

\begin{lemma}[Subtype Preservation for Types]
    If $[[G |- A1 <: B1 : k]]$, $[[A1 ==> A2]]$ and $[[B1 ==> B2]]$,
    then $[[G |- A2 <: B2 : k]]$.
\end{lemma}

% \bruno{I think that, at the start of the explanation, a better high-level description
%   of what's going on is needed. You need to state that we are interested in two different
%   subtype preservation lemmas, because reduction is used in two different ways (at runtime
%   and at the type-level). Moreover reudction at the type-level is the usual one (not erased), whereas
%   at runtime we use (or can use) erased reduction. Then briefly state that each of those results
% has some associatted challenges. }

\paragraph{Implicit Instantiations}
The proof of two cases for implicit instantiations (\rref{r-inst,r-cast-inst})
are quite similar. The implicit
instantiations are only triggered by \rref{s-forall-l}, which is where
polymorphic types are instantiated. The implicit arguments are the
mono-expressions that instantiate polymorphic types. The types of the results of
the implicit instantiations are the instantiation of the polymorphic types.
Then the rest of the proofs are finished by standard inversion lemmas,
with the help of the substitution lemma for the instantiations.

\subsection{Equivalence to a Simplified System}
We mentioned in Section \ref{sec:type-system} that the premises marked in gray in the
unified subtyping rules are redundant. They help in the formalization, but the calculus
is equivalent to a variant of the calculus without them. We define system
$[[G |= e1 <: e2 : A]]$, whose rules are the same as the typing rules of \name,
but with all redundant premises eliminated. Also, \rref{s-castdn,s-castup}
are also simplified to use deterministic reduction ($A \longrightarrow_D B$)
instead of the reduction rule $A \longrightarrow B$ as shown below (other rules omitted):

\begin{drulepar}[ss]{$[[G |= e1 <: e2 : A]]$}{Simplified Unified Subtyping}
    \ottaltinferrule{ss-castdn}{width=20em}
      {[[G |= e1 <: e2 : A]] \\ \rulehl{[[A ==> B]]} \\ [[G |= B : k]]}
      {[[G |= castdn e1 <: castdn e2 : B]]}
    \and
    \ottaltinferrule{ss-castup}{width=20em}
      {[[G |= e1 <: e2 : B]] \\ \rulehl{[[A ==> B]]} \\ [[G |= A : k]]}
      {[[G |= castup [A] e1 <: castup [A] e2 : B]]}
\end{drulepar}

We prove that the two system are equivalent in terms of expressiveness.

\begin{theorem}[Equivalence of \name and the Simplification]
  If $[[G |- e1 <: e2 : A]]$ then $[[G |= e1 <: e2 : A]]$.
  And if $[[G |= e1 <: e2 : A]]$ then $[[G |- e1 <: e2 : A]]$.
\end{theorem}

\subsection{Subsumption of Polymorphic Subtyping}

Finally we show that the subtyping aspect of \name subsumes
Odersky and L\"aufer's polymorphic
subtyping~\cite{odersky1996putting}.
\begin{figure}
    \begin{mathpar}
        \lift{x} = x \and \lift{[[int]]} = [[int]] \and
        \lift{A \rightarrow B} = \lift{A} \rightarrow \lift{B} \and
        \lift{\forall x. \, A} = \forall x : [[*]]. \, \lift{A} \and
    \end{mathpar}
    \begin{mathpar}
        \lift{[[nil]]} = [[nil]] \and
        \lift{\Gamma, \, x} = \lift{\Gamma},\, x : [[*]]
    \end{mathpar}
    \caption{Lifting Types and Contexts in DK's Sutyping to \name}
    \label{fig:lift}
\end{figure}
Figure \ref{fig:lift} shows the transformation from Odersky and L\"aufer's types to \name's types. Then we prove the subsumption in terms type well-formedness and subtyping
by following the interpretation of unified subtyping.

\begin{theorem}[Subsumption of Type Well-formedness]
    If $\Gamma \vdash A$, then $\lift{\Gamma} \vdash \lift{A} : [[*]]$
\end{theorem}

\begin{theorem}[Subsumption of Polymorphic Subtyping]
    If $\Gamma \vdash A \le B$, then $\lift{\Gamma} \vdash \lift{A} \le \lift{B} : [[*]]$
\end{theorem}

The proof is straightforward by making use of the \emph{well-formedness} lemma
in Odersky and L\"aufer system, mentioned in Section \ref{sec:adaptation}, to conclude that
$A$ itself is a well-formed type in $\Gamma \vdash A \le \forall x.\, B$, and
$\forall x. A$ is well-formed in $\Gamma \vdash \forall x. \, A \le B$.

% \bruno{The lemma that shows that the redundant premises are indeed redundant is not shown, right?
%   I think it should appear somewhere in Section 3.2.}

% \bruno{After reading this section, I feel that the text in Section 3.1 should come in Section 2 instead.}
