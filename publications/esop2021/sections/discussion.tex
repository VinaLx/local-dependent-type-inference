\section{Discussions and Future Work}

\subsection{Design Choices of the Semantics around Cast Operators}
\label{sec:cast-design}

The type reduction in cast operators is potentially under a context that
is not empty, so it is likely that we are performing reduction to an open term.
Intuitively we should generalize the definition of value by introducing inert
terms~\cite{yang2017unifying} to handle open term reduction.
However since we adopt the call-by-name semantics of PITS~\cite{yang2019pure},
there is no value check during the reduction. Whether the result of reduction
inside cast operator does not matter during the reasoning of type safety. It is
not necessary to complicate the metatheory by introducing inert terms.

An alternative design
around cast operators is the call-by-value (CBV) style~\cite{yang2019pure},
by not considering all $\castup$ terms as values, and performing cast elimination only
when the expression inside two casts is a value. Such design requires us to
have a more general definition of value, and thus there is a need for inert terms.

However, a simple design with CBV-style cast semantics and inert terms
potentially lead to a system where \emph{Reduction Substitution} does not hold,
for example:
\begin{gather*}
    \castdn \, \castup \, [A] \, (f ~ x) \longrightarrow f ~ x \\
    [\lambda x : B. \, x / f] \, \castdn \, \castup \, [A] \, (f ~ x) \longrightarrow \castdn \, \castup \, [A] \, x
\end{gather*}
So we stick with the call-by-name style semantics around cast operators and
leave the discussion of other possibilities of design in future work.

\subsection{Kind Restrictions on Polymorphic Types}

Currently, we impose restrictions on the kinding of polymorphic types
($\forall x : A. B$) to require that they only have kind $\star$ but not $[[box]]$.
We believe that this has little impact on the usability
of our system since we do not really polymorphic
kinds such as $\forall x : [[int]].\,\star$ do not appear frequently in practice.
However it would be reasonable not to have this restriction, but then
this complicates the development of the metatheory significantly.

One of the obstacles of removing the kind restriction is that,
there is a mutual dependency between the transitivity theorem and the subtyping
reasoning of polymorphic kinds. We wish to have some lemma like this:
\begin{mathpar}
    \inferrule*[]
      {[[G |- e : A]] \\ [[G |- e : *]]}
      {[[G |- * <: A : box]]}
\end{mathpar}
\noindent which depends on transitivity when the derivation of $[[G |- e : A]]$ ends with
subsumption rule (rule \rref{s-sub}).

Note that the reverse variant of the lemma
(If $[[G |- e : A]]$ and $[[G |- e : *]]$ then $[[G |- A <: * : box]]$) is not generally
true. A counter example is $A : \star \vdash \forall a : A.\, \star \le \star$, which
does not hold. We are unable to find a well-typed instantiation of an arbitrary type $A$,
which breaks the transitivity, while the derivation of the first premise ends
with \rref{s-forall-l}:
\begin{mathpar}
    \inferrule*[]
      {[[G |- [t / x] e1 <: e2 : *]] \\ [[G |- e2 <: e3 : A]]}
      {[[G |- forall x : A. e1 <: e3 : *]]}
\end{mathpar}
We cannot apply \rref{s-forall-l} unless $e_3$ is of type $[[*]]$,
i.e. $[[G |- A <: * : box]]$, which does not always holds, or the principal
type of $e_3$ is $[[*]]$ and $[[G |- * <: A : box]]$.

Moreover, we expect complexities while reasoning about the kinding of types
after we lose the kinding uniqueness in other parts of the metatheory, therefore
we leave the relaxation of the kinding restrictions for future work.

\subsection{Runtime Relevance of Implicit Arguments}

In our language, the implicit arguments have no computational impact at runtime
and only provide the necessary scoping for type annotations. This is
a similar design to ICC~\cite{miquel2001implicit} and
ICC*~\cite{barras2008implicit} to simplify the development of a direct
operational semantics for our language. Such restriction can be lifted if we
prove the runtime type-safety by elaboration to a second language,
such as \emph{the Calculus of Constructions}\cite{coc},
instead of providing the direct operational semantics.

We can elaborate the implicit function types (universal types) to $\Pi$ types,
implicit abstraction to lambda expression and implicit instantiation to explicit
application during type checking, when we have full information about the
choice of implicit instantiations. However the elaboration on a unified subtyping
system is not an easy task, because the subtyping relation cannot simply be interpreted
to a coercion between values of different types, while half of our subtyping
rules involve the subtype relation between terms instead of types.
Therefore we leave the exploration of how elaboration can be done
on a unified subtyping system as future work.

\subsection{Algorithmic System and Challenges}

\name does not currently have an algorithmic system since we
consider a formalized algorithm for dependent type system itself a challenge so it
is left for future work. While trying to compare to existing algorithmic systems
for higher-ranked polymorphic type inference for System F-like languages
~\cite{dunfield2013complete,zhao19mechanical},
we identify the following challenges to develop an algorithmic system for our language

\paragraph{Unification Inside Binders}
In dependent type systems, function types ($\Pi$ type) are dependent so that
the type of applications potentially depends on the values of their arguments.
Therefore the unification problem we meet is potentially inside binders and
depends on the value of the arguments.
For a extreme example in our language:

\begin{equation*}
    \lambda F : [[int]] \rightarrow F.\, \lambda f : F~42 \rightarrow [[int]].\, f ((\Lambda A : \star.\,\mu x : A.\, x)~42)
\end{equation*}

Here the principal type of $\Lambda A : \star.\,\mu x : A.\, x$ is $\forall A : \star.\, A$.
In a non-depedent setting one can easily conclude the instantiation for type $A$ to be
$F~42 \rightarrow [[int]]$. However with the presence of dependent types,
we are looking at the type $(\Pi x : [[int]].\, F e)$ where expression $e$
satisfy the equation that $[42/x]\,e = 42$ according to the Rule \rref{s-app}.
Note that, although we do not allow implicit type reduction in our system,
so that the unification problem here stay at first-order, we still face the
problem where we have to solve
the unification problem involving substitution. Moreover, in this case expression
$e$ has two solutions, namely variable $x$ and $42$. We consider coming up with
a formal system a challenging problem to resolve the general issues that this
example implies.

\paragraph{Inhabitation Problem}

In polymorphic subtyping, we do not need a ``real'' instantiation to conclude
that a subtyping relation holds. For example, in polymorphic subtyping:
\begin{equation*}
    \forall A.\, (A \rightarrow A) \rightarrow [[int]] \le (\forall A.\, A \rightarrow A) \rightarrow [[int]]
\end{equation*}
\noindent holds by first applying rule $\forallL$ with a dummy instantiation,
say $[[int]]$, and then showing $\forall A.\, A \rightarrow A \le [[int]] \rightarrow [[int]]$.
This clearly holds by applying rule $\forallL$ again. However such dummy instantiations
pose extra difficulties in \name:
\begin{equation*}
    \forall A : T.\, (A \rightarrow A) \rightarrow [[int]] \le (\forall A : T.\, A \rightarrow A) \rightarrow [[int]]
\end{equation*}
We cannot apply \rref{s-forall-l} until we find a valid instantiation for type $A$,
therefore we encounter an ``inhabitation problem'' for our system, asking the
inhabitant for an arbitrary type in our system. This problem is
undecidable for System F~\cite{dudenhefner2019simpler}. We do not expect it to be
decidable in a more complicated system with strong normalization.
While we support general recursion in our language, so that all types are
likely to be inhabited, we currently do not have the proof that this is the case.
