\section{Discussions}

\subsection{The Trouble with Instantiation in Subtyping}
\label{sec:instantiation}

One of the features of DK's subtyping is that the instantiation of implicit type
parameter happen during subtyping of polymorphic types. It makes sense when
viewing the subtyping relation as a more-general-than relation. A polymorphic
type is a subtype of another when we can find specific instantiation of the
type parameter. This idea works well in DK's system, but brings troubles
in the realm of dependent types, consider the following subtyping relation:

\begin{equation*}
    A : [[*]] \vdash [[forall x : A. int]] <: [[int]] : [[*]]
\end{equation*}

The relation above is not derivable in \name, because the type of implicit type
parameter is an abstract type, for which we are not able to find an well-typed
instantiation except for the infinite loop $\mu x : A.\, x$, this is the also the
case when $A$ in an arbitrary uninhabited types (without the help of a fixpoint).

This situation also assign a special role to variables in the context,
for example:

\begin{multline*}
    A : [[*]],\, F : A \rightarrow [[*]],\, \rulehl{a : A} \vdash \\
    \forall x : A.\, (F~x \rightarrow F~x) \rightarrow [[int]] \le (\forall x : A.\, F~x \rightarrow F~x) \rightarrow [[int]] : [[*]]
\end{multline*}

Without the help of the fixpoint, this subtyping relation is only derivable
with the presence of the highlighted variable in the context. The relation has to
be derived from \rref{s-forall-l}, which requires a well-typed instantiation for
the parameter, in this case, only $x$ is eligible even though it does not occur
anywhere in the expression except for the context.

The help of fixpoint does not solve the general problem, because
in \name the fixpoint expressions are only well-typed when it is not a polymorphic
type. So the general ``Strengthening'' lemma is not admissible in \name. Even
a restricted case where we only consider typing complicated examples can still
be construct to stop us from eliminating the a variable in the context even
when it is fresh everywhere else:

\begin{equation*}
    F : [[int]] \rightarrow [[*]],\, A : [[*]],\, \rulehl{a : A} \vdash F ~ ([[(bind x : A. lambda y : int. y)]]~ 42) : [[*]]
\end{equation*}

For the time being, we think the addition of the premise in \rref{s-forall-r} and
the addition of \rref{s-forall} do not complicate the metatheory as much, so
we leave the further exploration of the issue above in a future work.

\subsection{Design Choices of the Semantics around Cast Operators}
\label{sec:cast-design}

The type reduction in cast operators is potentially under a context that
is not empty, so it is likely that we are performing reduction to a open term.
Intuitively we should generalize the definition of value by introducing inert
terms\cite{yang2017unifying} to handle open term reduction.

However since we adopts the Call-by-Name semantics of Pure Iso-type System\cite{yang2019pure},
there is no value check during the reduction, and whether the result of reduction
inside cast operator does not matter during the reasoning of type safety. It is
not necessary to complicate the metatheory by introducing inert terms.

An alternate design around cast operator is the Call-by-Value (CBV) style\cite{yang2019pure},
by not considering all $\castup$ terms as value, and performing cast elimination only
when the expression inside two casts is a value. Such design requires us to
have a more general definition for value, and thus there is a need for inert terms.

However, a simple design with CBV-style cast semantics and inert terms
potentially lead to a system where \emph{Reduction Substitution} does not hold,
for example:

\begin{gather*}
    \castdn \, \castup \, [A] \, f ~ x \longrightarrow f ~ x \\
    [\lambda x : B. \, x / f] \castdn \, \castup \, [A] \, f ~ x \longrightarrow \castdn \, \castup \, [A] x
\end{gather*}

So we stick with the Call-by-Name style semantics around cast operators and
leave the discussion of other possibilities of design in a future work.
