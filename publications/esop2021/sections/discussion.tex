\section{Discussions and Future Work}

\begin{comment}
\subsection{The Trouble with Instantiation in Subtyping}
\label{sec:instantiation}

One of the features of DK's subtyping is that the instantiation of implicit type
parameter happen during subtyping of polymorphic types. It makes sense when
viewing the subtyping relation as a more-general-than relation. A polymorphic
type is a subtype of another when we can find specific instantiation of the
type parameter. This idea works well in DK's system, but brings troubles
in the realm of dependent types, consider the following subtyping relation:

\begin{equation*}
    A : [[*]] \vdash [[forall x : A. int]] <: [[int]] : [[*]]
\end{equation*}

The relation above is not derivable in \name, because the type of implicit type
parameter is an abstract type, for which we are not able to find an well-typed
instantiation except for the infinite loop $\mu x : A.\, x$, this is the also the
case when $A$ in an arbitrary uninhabited types (without the help of a fixpoint).

This situation also assign a special role to variables in the context,
for example:

\begin{equation*}
    A : [[*]],\, F : A \rightarrow [[*]],\, \rulehl{a : A} \vdash
    \forall x : A.\, (F~x \rightarrow [[int]]) \le (\forall x : A.\, F~x) \rightarrow [[int]] : [[*]]
\end{equation*}

Without the help of the fixpoint, this subtyping relation is only derivable
with the presence of the highlighted variable in the context. The relation has to
be derived from \rref{s-forall-l}, which requires a well-typed instantiation for
the parameter, in this case, only $x$ is eligible even though it does not occur
anywhere in the expression except for the context.

The help of fixpoint does not solve the general problem, because
in \name the fixpoint expressions are only well-typed when it is not a polymorphic
type. So the general ``Strengthening'' lemma is not admissible in \name. Even
a restricted case where we only consider typing complicated examples can still
be construct to stop us from eliminating the a variable in the context even
when it is fresh everywhere else:

\begin{equation*}
    F : [[int]] \rightarrow [[*]],\, A : [[*]],\, \rulehl{a : A} \vdash F ~ ([[(bind x : A. lambda y : int. y)]]~ 42) : [[*]]
\end{equation*}

For the time being, we think the addition of the premise in \rref{s-forall-r} and
the addition of \rref{s-forall} do not complicate the metatheory as much, so
we leave the further exploration of the issue above in a future work.
\end{comment}

\subsection{Design Choices of the Semantics around Cast Operators}
\label{sec:cast-design}

The type reduction in cast operators is potentially under a context that
is not empty, so it is likely that we are performing reduction to a open term.
Intuitively we should generalize the definition of value by introducing inert
terms\cite{yang2017unifying} to handle open term reduction.

However since we adopts the Call-by-Name semantics of Pure Iso-type System\cite{yang2019pure},
there is no value check during the reduction, and whether the result of reduction
inside cast operator does not matter during the reasoning of type safety. It is
not necessary to complicate the metatheory by introducing inert terms.

An alternate design around cast operator is the Call-by-Value (CBV) style\cite{yang2019pure},
by not considering all $\castup$ terms as value, and performing cast elimination only
when the expression inside two casts is a value. Such design requires us to
have a more general definition for value, and thus there is a need for inert terms.

However, a simple design with CBV-style cast semantics and inert terms
potentially lead to a system where \emph{Reduction Substitution} does not hold,
for example:

\begin{gather*}
    \castdn \, \castup \, [A] \, f ~ x \longrightarrow f ~ x \\
    [\lambda x : B. \, x / f] \, \castdn \, \castup \, [A] \, f ~ x \longrightarrow \castdn \, \castup \, [A] \, x
\end{gather*}

So we stick with the Call-by-Name style semantics around cast operators and
leave the discussion of other possibilities of design in a future work.

\subsection{Kind Restrictions on Polymorphic Types}

Currently we impose restrictions on the kinding of polymorphic types
($\forall x : A. B$) to require they only have kind $\star$ but not $[[box]]$
, which has little impact on the practicality
of our system since we do not really mind not being able to have the polymorphic
kind $\forall x : [[int]].\,\star$. But we also does not have a real reason
to not allow the existence of such kind except that it complicates the development
of metatheory by a big margin.

One of the obstacles of removing the restriction is the mutual dependency
between reasoning subtyping relation of polymorphic kinds and the transitivity theorem,
where we wish to have some lemma like this:

\begin{mathpar}
    \inferrule*[]
      {[[G |- e : A]] \\ [[G |- e : *]]}
      {[[G |- * <: A : box]]}
\end{mathpar}

which depends on transitivity when the derivation of $[[G |- e : A]]$ ends with
subsumption rule (rule \rref{s-sub}).

Note that the reverse variant of the lemma
(If $[[G |- e : A]]$ and $[[G |- e : *]]$ then $[[G |- A <: * : box]]$) is not generally
true with the counter example that $A : \star \vdash \forall a : A.\, \star \le \star$
does not hold, since we are unable to find a well-typed instantiation of an arbitrary type $A$,
which breaks the transitivity while the derivation of the first premise ends
with \rref{s-forall-l}:

\begin{mathpar}
    \inferrule*[]
      {[[G |- [t / x] e1 <: e2 : *]] \\ [[G |- e2 <: e3 : A]]}
      {[[G |- forall x : A. e1 <: e3 : *]]}
\end{mathpar}

We cannot apply \rref{s-forall-l} unless $e_3$ is of type $[[*]]$,
i.e. $[[G |- A <: * : box]]$, which does not always holds, or the principal
type of $e_3$ is $[[*]]$ and $[[G |- * <: A : box]]$.
Overall, this is a situation we do not currently understand.

Moreover, we expect complexities while reasoning about the kinding of types
after we lose the kinding uniqueness in other parts of the metatheory, therefore
we leave the relaxation of the kinding restrictions for future work.

\subsection{Runtime Relevance of Implicit Arguments}

In our language, the implicit arguments have no computational impact at runtime
and only provide the necessary scoping for type annotations. This is
a similar design to ICC\cite{miquel2001implicit} and
ICC*\cite{barras2008implicit} to simplify the development of a direct
operational semantics for our language. Such restriction can be lifted, if we
prove the runtime type-safety by elaboration to a second language,
such as \emph{the Calculus of Constructions}\cite{coc},
instead of providing a direct operational semantics.

We can elaborate the implicit function types (universal types) to $\Pi$ types,
implicit abstraction to lambda expression and implicit instantiation to explicit
application during type checking, when we have full information about the
choice of implicit instantiations. However the elaboration on a unified subtyping
system is not an easy task, because the subtyping relation cannot simply be interpreted
to a coercion between values of different types, while a half of our subtyping
rules involve the sub-``type'' relation between ``terms'' instead of ``types''.
Therefore we leave the exploration of how elaboration can be done
on a unified subtyping system as a future work.

\subsection{Algorithmic System and Challenges}

\name does not currently have a algorithmic system since we
consider a formalized algorithm for dependent type system itself a challenge so it
is left for future work. While trying to compare to the algorithmic system
of higher-ranked polymorphism based on system F
\cite{dunfield2013complete,zhao19mechanical}
we identify following challenges to develop an algorithmic system for our language

\paragraph{Higher-Order Unification}

In dependent type systems, function types ($\Pi$ type) are dependent so that
the type of applications potentially dependend on the values of their arguments.
This creates the scenario of higher-order unification where the unifier is
second-order terms (functions). For a extreme example in our language:

\begin{equation*}
    \lambda f : [[int]] \rightarrow [[int]].\, f ((\Lambda A : \star.\,\mu x : A.\, x)~42)
\end{equation*}

Here the principal type of $\Lambda A : \star.\,\mu x : A.\, x$ is $\forall A : \star.\, A$.
In a non-depedent setting one can easily conclude the instantiation for type $A$ to be
 $[[int]] \rightarrow [[int]]$. However with dependent types we are looking at
the type $(\Pi n : [[int]].\, F(n))$ for all possible $F$ such that $F(42) = [[int]]$.
The general problem of higher-order unification is known to be undecidable\cite{goldfarb1981undecidability}
and the decidable variant ``pattern unification''\cite{miller1991unification}
is yet to have a clear specification.
So we are not yet sure about how to tackle or workaround the situation in order
for our system to be well-specified and mechanized.

\paragraph{Inhabitation Problem}

In polymorphic subtyping, we do not need a ``real'' instantiation to conclude
a subtyping relation holds, for example in polymorphic subtyping:

\begin{equation*}
    \forall A.\, (A \rightarrow A) \rightarrow [[int]] \le (\forall A.\, A \rightarrow A) \rightarrow [[int]]
\end{equation*}

The subtyping holds by first applying rule $\le\forall L$ with a dummy instantiation,
say $[[int]]$, and then showing $\forall A.\, A \rightarrow A \le [[int]] \rightarrow [[int]]$
which clearly holds by applying rule $\le\forall L$ again. However the situation
complicates in our system:

\begin{equation*}
    \forall A : T.\, (A \rightarrow A) \rightarrow [[int]] \le (\forall A : T.\, A \rightarrow A) \rightarrow [[int]]
\end{equation*}

We cannot apply \rref{s-forall-l} until we find a valid instantiation for type $A$,
therefore we encounter an ``inhabitation problem'' for our system, asking the
inhabitant for an arbitrary type in our system. And while such problem is
undecidable for system F\cite{dudenhefner2019simpler}, we do not expect it to be
decidable in a more complicated system. So a design is required to workaround
this situation and we are unsure about how we are going to do that.
