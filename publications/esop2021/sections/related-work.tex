\section{Related Work}

\bruno{We should talk about Ningning's work at POPL. Some text, which needs to be improved,
is shown next.}
Indeed, the current GHC Haskell's language of types and kinds
is already dependently typed, and has no type conversion. Recent work by
Xie et al.~\cite{xie20kind} describes algorithms and specifications
for the form of (dependently typed) type-inference currently present in GHC Haskell.
In GHC Haskell there are no type-level lambdas and thus no type conversion
(although type-level computation can be achieved by other means at the source
level~\cite{Chakravarty05associated}). In our work we do allow type-level lambdas
but lambdas can only be equal up to $\alpha$-equivalence.
Thus our focus is on Haskell-like languages with dependently typed
features and explicit casts, rather than languages like Agda or Idris
which typically have a conversion rule that triggers implicit type level
computation.

\paragraph{Implicit Dependent Type Calculus}

The implicit calculus of constructions (ICC\cite{miquel2001implicit} and
ICC*\cite{barras2008implicit}) discuss implicit polymorphism in dependently-typed
setting.

ICC features the generalized polymorphic types and typing rules to express
the idea of implicit instantiation. They do not explicitly have a subtyping
relation between polymorphic types, therefore the expressiveness of reasoning
between polymorphic types are limited to the top level polymorphic types. The
implicit parameters does not impact the runtime semantics of ICC and therefore
is not modeled and discussed.

The implicit function types of ICC* are not interpreted as polymorphic
function types, since their main focus is on the distinction between implicit
functions (universal types and implicit abstraction) and explicit functions
($\Pi$-types and lambda abstraction).
The typing rules about implicit part and explicit part of the language mirror
each other, the generalization and instantiation aspect of the implicit function
types are not featured. ICC* depends on its tranformation to ICC to obtain type safety
of the language, therefore the parameters of implicit functions have no impact
on runtime behavior as well and only serves the well-scopeness of type annotations.

\paragraph{Type-inference and unification with dependent types}
\bruno{This paragraph should be improved and expanded. }
There has been little work on formalizing type inference for calculi
with dependent types, although essentially all implementations of
theorem provers or dependently typed languages perform some form of
type-inference.
One important challenge is that type inference for
many systems with dependent types requires \emph{higher-order unification},
which is known to be undecidable
~\cite{goldfarb1981undecidability}. The \textit{pattern}
fragment~\cite{miller1991unification} is a well-known decidable
fragment. Much literature on unification for dependent
types~\cite{reed2009higher,abel2011higher, gundry2013tutorial, Cockx:2016:UEP:2951913.2951917, ziliani2015unification, coen2004mathematical} is
built upon the pattern fragment. Algorithms for type-inference used in Agda and
(Dependent) Haskell have been described and formalized to some degree
in various theses~\cite{norell,gundry,dh}. However as far as we know
there is not a clear specification and complete metatheory (let alone
mechanized) for such algorithms. In the \emph{implicit calculus of
 constructions}~\cite{Miquel01} an elegant (but purely declarative) curry-style
version of the calculus of constructions is presented. As the author
suggests type-inference for this calculus without annotations is undecidable.

\paragraph{Type-inference for higher-ranked polymorphism}
Type-inference for \emph{higher-ranked polymorphism}
(HRP)~\cite{dunfield2013complete,le2003ml,leijen2008hmf,vytiniotis2008fph,jones2007practical,Serrano2018, odersky1996putting}
extends the classic Hindley-Milner algorithm~\cite{hindley1969principal,milner1978theory,damas1982principal},
removing the restriction of top-level (let) polymorphism only. Type
inference for HRP aims at providing inference for System F-like
languages. In particular existing HRP approaches allow \emph{synthesis of type arguments}
and use type annotations to aid
inference, since type-inference for full System F is
well-known to be undecidable~\cite{wells1999typability}.

The work on HRP is divided into two strands: \emph{predicative} HRP~\cite{dunfield2013complete,jones2007practical,odersky1996putting,dunfield2019sound}
and \emph{impredicative} HRP~\cite{le2003ml,leijen2008hmf,vytiniotis2008fph,Serrano2018}.
In predicative HRP instantiations can
only synthesize monotypes, whereas in impredicative HRP there's no
such restriction. However impredicative HRP is quite complex because
the polymorphic subtyping relation for impredicative HRP is undecidable~\cite{tiuryn1996subtyping}.
Thus reasonable restrictions that work well in practice are still
a hot topic in research.
The monotype restriction on predicative instantiation is considered reasonable
and practical for most programs. It is currently in use by languages such as
(GHC) Haskell, Unison~\cite{Unison} and PureScript~\cite{PureScript}.
The original work of polymorphic subtyping by Odersky and L\"aufer also enforce
the monotype restriction in the subtyping rule (rule \forallL) to prevent
choosing a polytype in the instantiation. Based on polymorphic subtyping as
their declarative system,
% \bruno{mention Odersky and Laufer here before moving on to DK}
Dunfield and Krishnaswami (DK)~\cite{dunfield2013complete} develop an
algorithmic system for predicative HRP type inference. DK's algorithm was
manually proved to be sound, complete and decidable.
With a more complex declarative system~\cite{dunfield2019sound}, DK
extended their original work with new features.\bruno{For the last paper, I think it supports
  some interesting features that are closer to dependent types, so we should
summarize that in a few sentences.}

\paragraph{MLSub} A recent breakthrough in the area of (global) type-inference
for type systems with subtyping is MLSub~\cite{dolan17polymorphism}. MLSub extends the Hindley-Milner
type system with support for subtyping. A key innovation
of MLSub is that it has compact principal types, which had been a challenge
in previous research on type-inference in the presence of subtyping~\cite{eifrig95inference,Trifonov96subtyping,pottier1998inference}.
MLSub is significantly more ambitious than local type-inference, and requires
no annotations (in the tradition of Hindley-Milner). However MLSub does not
account for HRP and its algorithms and metatheory have not been mechanically
formalized.

\paragraph{Dependent Types and Subtyping}
In essence the big difficulty is that the introduction of dependent
types makes typing and subtyping depend on each other. This causes
several difficulties in developing the metatheory for calculi that
combine dependent types and subtyping. Practically all previous
work~\cite{subdep,ptssub,chen1,cocsub,Chen03coc} attempts to address such problem by somehow
\emph{untangling} typing and subtyping, which has the benefit that the
metatheory for subtyping can be developed before the metatheory of
typing. Nevertheless, several results and features prove to be
challenging. For example, many calculi~\cite{subdep,ptssub}
drop the support of \emph{top types}, which are essential in OOP
programs to model the universal base class. Transitivity is difficult
to prove as it may be entangled with other properties such as
subject reduction and strong normalization.
Several studies~\cite{subdep,chen1} have
to use sophisticated techniques to show that transitivity
holds. Hutchins \emph{Pure
  Subtype Systems}~\cite{hutchins} take a different approach, by
eliminating typing and making subtyping the essential notion in the
calculus.  While this simplifies the syntax and typing rules, the metatheory is complex. Hutchins failed
to prove transitivity elimination and left
important lemmas that depend on transitivity, such as
subject reduction as
conjectures instead.
None of these calculi manages to subsume
System \fsub~\cite{fsub}, together with its desirable properties (for
example transitivity elimination and subject reduction). System
\fsub is a standard polymorphic calculus with subtyping, often
identified as a canonical calculus capturing
essential OOP features (and especially bounded quantification).
Given the importance of System \fsub as a foundational
model for OOP, it seems highly desirable that a dependently
typed OOP calculus subsumes it.

Our work builds on the work done on Pure Iso-Type Systems (PITS)~\cite{yang2019pure}, and

\emph{unified subtyping}~\cite{full}. PITS is a variant of pure type systems (PTSs),
which captures a family of calculi with \emph{iso-types}. Iso-types generalize \emph{iso-recursive
types}~\cite{tapl}, and provide a simple form of
type casts to address the combination of recursion and
dependent types.
Yang and Oliveira~\cite{full} introduces \name, which extends
\lami with support for OOP features such as
\emph{higher-order subtyping}~\cite{fsubo}, \emph{bounded quantification} and
\emph{top types}.
To address the challenges posed by
the combination of dependent types and subtyping, \name
employs \emph{unified subtyping}: a novel technique that unifies
\emph{typing}, \emph{subtyping} and \emph{well-formedness} into one
relation. Therefore, \name takes a significantly different
approach compared to previous work, which
attempts to fight the entanglement between typing and subtyping. In
contrast, \name embraces such
tangling by collapsing the typing and subtyping
relations into the same relation. This approach is different from
Hutchins' technique, which eliminates typing relation and embed it into
the combination of subtyping, well-formedness and reduction relations.
While unified subtyping
retains the tradition concept of typing and subtyping, which are just the two
projections of the unified relation.
% \name retains types. \bruno{Text summarizing differences from our work}


\paragraph{Dependent Types with Explicit Casts} Previously
discussed work is about the interaction between dependent types and
subtyping. However, the other problem is the
interaction between dependent types and recursion. For this
problem, a general solution that has recently emerged is the use
of type casts to control type-level computation. In such an approach explicit casts
are used for performing type-level computation. A motivation for
using type casts is to decouple strong normalization from the
proofs of metatheory, which also makes it possible to allow general
recursion. There have been several studies~\cite{guru,sjoberg:msfp12,
  kimmel:plpv, zombie:popl15, fc:kind, Doorn:2013hq,isotype} working
on using explicit casts instead of conversion rule in a dependently
typed system. \bruno{We should probably add some more detail here.}
