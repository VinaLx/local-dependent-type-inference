\section{\System}

This section introduces the static and dynamic semantics of
\name: a dependently typed calculus with type casts
and implicit polymorphism. The calculus employs
\emph{unified subtyping}~\cite{CoquandThierry1988Tcoc}
and has a single relation that generalizes both typing and subtyping.
The calculus can be seen as a variant of the \emph{calculus of constructions}~\cite{},
but it uses a simple form of casts~\cite{} instead of the conversion rule
and features unrestricted recursion. We present syntax, unified subtyping
and reduction for \name.

\begin{figure}[t]
\centering
\begin{equation*}
\begin{array}{llcl}
    \text{Kinds} & k & ~\Coloneqq ~ & [[*]] \mid [[box]] \\
    \text{Expressions} & e, A, B & ~ \Coloneqq ~ & [[x]] \mid [[n]] \mid [[k]] \mid [[int]] \mid [[e1 e2]] \mid [[lambda x : A. e]]
        \mid [[pi x : A. B]] \mid [[bind x : A. e]] \\
        & & \mid & [[forall x : A. B]] \mid [[mu x : A. e]] \mid [[castup [A] e]] \mid [[castdn e]]   \\
    \text{Mono-Expressions} ~ & \tau, \sigma & ~ \Coloneqq ~ & [[x]] \mid [[n]] \mid [[k]] \mid [[int]] \mid \tau_1 ~ \tau_2 \mid \lambda \, x : \tau. ~ \sigma \mid \Pi \, x : \tau. ~ \sigma \mid \Lambda \, x : \tau. ~ \sigma \\
        & & \mid & \mu \, x : \tau. ~ \sigma \mid \castup \, [\tau]~ \sigma \mid \castdn \, \tau \\
    \text{Values} & v & ~ \Coloneqq ~ & [[k]] \mid [[n]] \mid [[int]] \mid [[lambda x : A. e]] \mid [[pi x : A. B]] \mid [[bind x : A. e]] \\
        & & \mid & [[forall x : A. B]] \mid [[castup [A] e]] \\
    \text{Contexts} & \Gamma & ~ \Coloneqq ~ & [[nil]] \mid [[G , x : A]] \\
    \text{Syntactic Sugar} ~ & A \rightarrow B & \triangleq & [[pi x : A. B]] \qquad \text{where} ~ x \notin \mathrm{FV}(B)
\end{array}
\end{equation*}
\caption{Syntax of \name.}
\label{fig:syntax}
\end{figure}
\bruno{Aren't we missing some monotype restrictions? Forall types should have monotype
  arguments, right? Please double check the restrictions, change the syntax if necessary
  and double-check the text.}
\bruno{Be careful with the margins: we are overflowing.}

\subsection{Syntax}

Figure \ref{fig:syntax} presents the syntax of \name. The syntax is similar
syntax to the Calculus of Constructions, featuring
$[[*]]$ and $[[box]]$ in the kind hierarchy, and unifying the concepts of terms
and types as expressions. Due to the unified syntax, types and 
expressions ($e$, $A$ and $B$) are used
interchangeably, although we mostly adopt the convention of using $A$ and $B$
for contexts where the expressions are used as types and $e$ for contexts
where the expressions represent terms.
The syntax includes all the constructs of the calculus of constructions:
variables ($[[x]]$), kinds ($[[k]]$), function applications  ($[[e1 e2]]$),
lambda expressions ($[[lambda x : A. e]]$), dependent function types ($[[pi x : A. B]]$)
as well as integer types ($[[int]]$) and integers ($[[n]]$).
Moreover, there are a number of additional language constructs for
supporting implicit polymorphism, recursion and explicit type-level computation
via casts. These constructs are discussed next.

\subsubsection{Implicit Polymorphism}

Forall types $[[forall x : A. B]]$ are used to generalize implicit
polymorphism in non-dependent languages. In contrast to non-dependent
universal quantification in conventional functional languages, the
arguments range over all well-typed expressions besides well-formed
types (i.e. $x$ can have any type $A$ instead of just $\star$).
In other words, ``polymorphic types'' are naturally dependent, so $\forall$
types can be viewed as the implicit counterpart of $\Pi$ types. We also have
implicit lambda expressions ($[[bind x : A. e]]$), which are the implicit counterpart of
  $\lambda$ abstractions. The design used in \name
  is similar to the design of $\text{ICC}^*$~\cite{barras2008implicit}, which
  employs similar constructs for implicit dependent products. 
Like conventional universal quantification, the arguments of $\forall$ types are
deduced during applications rather than being explicitly passed.
In addition, following designs for predicative higher-ranked polymorphism~\cite{oderskylufer,DK,PJ}, we have also generalized the concept of ``monotypes'' to
``mono-expressions'', essentially excluding $\forall$ types from expressions.

\subsubsection{Explicit Type-level Computation}
\label{sec:cast}
\System adopts the iso-types~\cite{yang2016unified}, featuring explicit type-level
computations with cast operators $\castdn$ and $\castup$. These operators
respectively perform one-step
type reduction and type expansion based on the operational semantics.
The reduction in cast operators is deterministic so that the type annotation is
only needed during type expansions ($\castup$).

\subsubsection{Fixpoint Operator}

Finally, we add fixpoints ($[[mu x : A. e]]$)
to support general recursion for both term-level
and type-level. Iso-recursive types are supported due to the presence of $\castup$
and $\castdn$, which correspond to the ``fold'' and ``unfold'' operations when
working on recursive types.
%However, we do not support subtyping for recursive
%types in the current system due to the complexity.

\subsection{Operational Semantics}

\bruno{If I understand correctly we need 2 different reductions, one
  (the non-deterministic one) that is used in the type system; and another
  one (which erases types) that is deterministic and would be the basis
  for an actual implementation of reduction at run-time. After reading
  this subsection, I think we want
to tell that story here and present the 2 variants of reduction here.}

Figure \ref{fig:semantics} presents the small-step operational semantics of our system,
which mostly follows the call-by-name variant of Pure Iso-Type Systems (PITS)
\cite{yang2019pure} corresponding to the calculus of constructions.
Note that the arguments of $\beta$-reduction (\rref{r-beta}) and expressions in
the \rref{r-cast-elim} are not required to be values.
Meanwhile we consider $\castup$ terms to be a value,
and only perform reduction inside $\castdn$ terms (\rref{r-castdn}). Also, the unroll
operation of fixpoint operator is supported by \rref{r-mu}.

\begin{figure}[t]
    \centering

    \drules[r]{$[[e1 --> e2]]$}{Operational Semantics}{
        app,beta,inst,mu,castdn,castXXinst,castXXelim}

    \caption{Operational semantics of \name.}
    \label{fig:semantics}
\end{figure}
\bruno{Do not use $mono~e$ in the figure.
  You have the syntax $\tau$ and $\sigma$ to represent
monotypes, so just use that instead.}

\subsubsection{Nondeterministic Implicit Instantiations}
The most interesting rules are those involving instantiation of implicit parameters:
\rref{R-Inst} and \rref{R-Cast-Inst}. These rules are not deterministic, or even
(in the general case) type-preserving. The main reason for this is due to the
guess of $e$, which can be an arbitrary monoexpression.
These issues are resolved by imposing restrictions on the type system such that
\textbf{a)} non-deterministic reductions are not well-typed inside cast operations
\textbf{b)} the instantiation choices of implicit parameters do not affect the
overall runtime type-safety. Details will be explained in the later sections.

\begin{figure}
    \centering
    \drules[wf]{$[[|- G]]$}{Well-formed Context}{nil,cons}

    \drules[s]{$[[G |- e1 <: e2 : A]]$}{Unified Subtyping}{
        var,lit,int,star,abs,pi,app,bind,mu,castup,castdn,forallXXl,forallXXr,forall,sub}
    \begin{equation*}
       \text{Syntactic Sugar} \qquad [[G |- e : A]] \triangleq [[G |- e <: e : A]]
    \end{equation*}
    \caption{(Sub)Typing Rules of \name.}
    \label{fig:typing}
\end{figure}
\bruno{The figure and rules will need a little cosmetic work. Firstly, there are many rules
  stacking up premises vertically. I think it is better to have multiple rules
  horizontally (and only upto 2 or 3 vertical stacks of premises).
  Secondly, we need to look at the layout carefully to use space efficiently.
  At the moment there are rules like S-ABS that could be paired up with some other
  rules side-by-side and use less space (at the same time it is nicer
  if adjancent rules are somehow related: two cast rules; application/abstraction, etc).
  We must organize the rules in a nicer way. Thirdly, I think that, for binders with
  annotations, like $\lambda x : A. e$, we may want to use brackets on the arguments
  to improve readability, as in $\lambda (x : A). e$. It is a bit hard to ``parse''
  the syntax without a little bit of effort. If this change is implemented it would
  affect the whole section, starting from syntax.
}

\subsection{Unified Subtyping System}

Figure \ref{fig:typing} shows the (sub)typing rules of the system. We adopt the design
of unified subtyping~\cite{yang2017unifying}, where the subtyping rules and
typing rules are merged into a single typing judgment $[[G |- e1 <: e2 : A]]$. 
Unified subtyping solves the traditional issue of mutual dependency between typing
and subtyping in a dependently type system.
The interpretation of this judgment is ``under context $[[G]]$, $[[e1]]$ is a
subtype of $[[e2]]$ and they are both of type $[[A]]$''.
In this form of formalization, the typing judgment $[[G |- e : A]]$ is a
special case of unified subtyping judgment $[[G |- e <: e : A]]$,
and the idea of well-formed types $\Gamma \vdash A$ is expressed by
$[[G |- A : k]]$ where $k$ is either $[[*]]$ or $[[box]]$.
\bruno{We should say something about the ``more standard'' rules here.
  I think we can briefly explain them and point the
  reader to Linus work for further details, while observing that the rules
  here are essentially simplified version (due to the absence of bounded quantification)
of his rules.}

\subsubsection{Rules for Universal Quantification}
The subtyping rules for universal quantification (\rref{s-forall-l,s-forall-r}) follow
the spirit of the Odersky and L\"aufer declarative subtyping rules~\cite{oderskylaufer,DunfieldJoshua2013Caeb},
where the subtyping relation is interpreted as a ``more general than'' relation.
A polymorphic type $\forall (x:A). B$
is more general than another type $C$ when its well-typed
instantiation is more general than $C$ (\rref{s-forall-l}). A polymorphic
type $\forall (x:B). C$ is less general than a type $A$,
if $C$ is is less general than $A$ when the argument with the polytype ($x:B$)
is abstracted out (\rref{s-forall-r}). Additionaly, \rref{s-forall}
axiomatizes the subtyping relation between two polymorphic types.
The motivation for \rref{s-forall} is discussed in more detail in later sections.

\subsubsection{Mono-expression Restrictions}
As in other predicative relations (such as the one by Odersky and L\"aufer),
the type arguments for instantiation in \rref{s-forall-l} are
required to be mono-expressions, which has cascading effects on typing rules of
other expressions. The arguments for applications are required to be
mono-expressions, and the whole fixpoint expression is required to be a
mono-expressions. We shall
discuss the reason behind the restrictions in later sections.
\bruno{I feel that we may be deferring a bit too much explanation
to later sections, but lets come back to this after you write later sections.}

\subsubsection{Kind Restriction for Universal Types}
\label{sec:kind-restriction}

For the kinding of types, we mainly follow the design of the Calculus of
Constructions~\cite{CoquandThierry1988Tcoc}. However, we specifically restrict
the $\forall (x : A). B$
expressions to only have the kind $[[*]]$. This prevents other types of kind
$[[*]]$ from having kinds such as $[[forall x : int. *]]$,
which significantly complicates the metatheory when reasoning about the kind of types.
This restriction propagates to the introduction rule of $\forall$ types (\rref{s-bind}),
where $[[B]]$ is required to only have kind $[[*]]$.
This way well-typed implicit abstractions ($\Lambda$ expressions) are kept away
from type computations. Therefore, in cast operators,
the possibility of non-deterministic implicit instantiations is eliminated.

\begin{figure}[t]
    \centering
    \begin{equation*}
        \begin{array}{llcl}
            \text{Extracted Expressions} & e, A, B & ~ \Coloneqq ~ & [[x]] \mid [[n]] \mid [[k]] \mid [[int]] \mid [[ee1 ee2]] \mid [[elambda x. ee]] \mid [[epi x : eA. eB]] \mid [[ebind x. ee]] \\
            & & \mid & [[eforall x : eA. eB]] \mid [[emu x. ee]] \mid [[ecastup ee]] \mid [[ecastdn ee]]
        \end{array}
    \end{equation*}

    \begin{equation*}
    {\setstretch{1.5}
    \begin{array}{cc}
        \extract{[[x]]} = [[x]] \qquad
        \extract{[[n]]} = [[n]] &
        \extract{[[k]]} = [[k]] \qquad
        \extract{[[int]]} = [[int]] \\
        \extract{[[e1 e2]]} = \extract{[[e1]]} ~ \extract{[[e2]]} &
        \extract{[[mu x : A. e]]} = \mu \, x. ~ \extract{[[e]]} \\
        \extract{[[lambda x : A. e]]} = \lambda \, x. ~ \extract{[[e]]} &
        \extract{[[pi x : A. B]]} = \Pi \, x : \extract{[[A]]}. ~ \extract{[[B]]} \\
        \extract{[[bind x : A. e]]} = \Lambda \, x. ~ \extract{[[e]]} &
        \extract{[[forall x : A. B]]} = \forall \, x : \extract{[[A]]}. ~ \extract{[[B]]} \\
        \extract{[[castup [A] e]]} = \castup \, \extract{[[e]]} &
        \extract{[[castdn e]]} = \castdn \, \extract{[[e]]}
    \end{array}
    }
    \end{equation*}

    \caption{Extraction of Expressions}
    \label{fig:extraction}
\end{figure}

\subsubsection{Runtime Irrelevance of Implicit Arguments}

Our direct operational semantics choose random mono-expressions to instantiate
the implicit arguments which potentially breaks type safety. So we adopt a
restriction that is similar to the Implicit Calculus of Constructions (ICC) \cite{miquel2001implicit}
to make the choice of implicit argument irrelevant to the computation, by only
allowing the implicit parameters to occur in type annotations in the body of
implicit abstraction. Figure \ref{fig:extraction} shows the extraction function
that gets rid of all the type annotations in expressions, and enforcing the
freshness of implicit parameter in the extracted expression. The type safety of
the direct operational semantics is proved indirectly with the help of
the extraction of expressions, which we will come back to in later sections.

\subsubsection{Redundant Premises}

All the premises highlight in gray are redundant in a way that
the system without them is proved equivalent to the system in figure \ref{fig:typing}.
They are there to simplify the mechanized proofs of certain lemmas.

