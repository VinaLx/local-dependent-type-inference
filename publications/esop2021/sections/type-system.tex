\section{\System}
\label{sec:system}

This section introduces the static and dynamic semantics of
\name: a dependently typed calculus with type casts
and implicit polymorphism. The calculus employs
\emph{unified subtyping}~\cite{CoquandThierry1988Tcoc}
and has a single relation that generalizes both typing and subtyping.
The calculus can be seen as a variant of the \emph{calculus of constructions}~\cite{},
but it uses a simple form of casts~\cite{} instead of the conversion rule
and features unrestricted recursion. We present syntax, unified subtyping
and reduction for \name.

\begin{figure}[t]
\centering
\begin{equation*}
\begin{array}{llcl}
    \text{Kinds} & k & ~\Coloneqq ~ & [[*]] \mid [[box]] \\
    \text{Expressions} & e, A, B & ~ \Coloneqq ~ & [[x]] \mid [[n]] \mid [[k]] \mid [[int]] \mid [[e1 e2]] \mid [[lambda x : A. e]] \mid [[pi x : A. B]] \\
        & & \mid & [[bind x : A. e]] \mid [[forall x : A. B]] \mid [[mu x : A. e]] \\
        & & \mid & [[castup [A] e]] \mid [[castdn e]]   \\
    \text{Mono-Expressions} ~ & \tau, \sigma & ~ \Coloneqq ~ & [[x]] \mid [[n]] \mid [[k]] \mid [[int]] \mid \tau_1 ~ \tau_2 \mid \lambda \, x : \tau. ~ \sigma \mid \Pi \, x : \tau. ~ \sigma \\
        & & \mid & \Lambda \, x : \tau. ~ \sigma \mid \mu \, x : \tau. ~ \sigma \mid \castup \, [\tau]~ \sigma \mid \castdn \, \tau \\
    \text{Values} & v & ~ \Coloneqq ~ & [[k]] \mid [[n]] \mid [[int]] \mid [[lambda x : A. e]] \mid [[pi x : A. B]] \mid [[bind x : A. e]] \\
        & & \mid & [[forall x : A. B]] \mid [[castup [A] e]] \\
    \text{Contexts} & \Gamma & ~ \Coloneqq ~ & [[nil]] \mid [[G , x : A]] \\
    \text{Syntactic Sugar} ~ & A \rightarrow B & \triangleq & [[pi x : A. B]] \qquad \text{where} ~ x \notin \mathrm{FV}(B)
\end{array}
\end{equation*}
\caption{Syntax of \name.}
\label{fig:syntax}
\end{figure}
\subsection{Syntax}

Figure \ref{fig:syntax} presents the syntax of \name. The syntax is similar
syntax to the Calculus of Constructions, featuring
$[[*]]$ and $[[box]]$ in the kind hierarchy, and unifying the concepts of terms
and types as expressions. Due to the unified syntax, types and
expressions ($e$, $A$ and $B$) are used
interchangeably, although we mostly adopt the convention of using $A$ and $B$
for contexts where the expressions are used as types and $e$ for contexts
where the expressions represent terms.
The syntax includes all the constructs of the calculus of constructions:
variables ($[[x]]$), kinds ($[[k]]$), function applications  ($[[e1 e2]]$),
lambda expressions ($[[lambda x : A. e]]$), dependent function types ($[[pi x : A. B]]$)
as well as integer types ($[[int]]$) and integers ($[[n]]$).
Moreover, there are a number of additional language constructs for
supporting implicit polymorphism, recursion and explicit type-level computation
via casts. These constructs are discussed next.

\paragraph{Implicit Polymorphism.}
In \name, universal types $[[forall x : A. B]]$ are used to generalize implicit
polymorphism in non-dependent.
In contrast to universal quantification in conventional functional languages, the
argument $x$ ranges over all well-typed expressions besides well-formed
types (i.e. $x$ can have any type $A$ instead of just kind $\star$).
In other words, ``polymorphic types'' are naturally dependent, so $\forall$
types can be viewed as the implicit counterpart of $\Pi$ types. We also have
implicit lambda expressions ($[[bind x : A. e]]$), which are the implicit counterpart of
  $\lambda$ abstractions. The design used in \name
  is similar to the design of the \emph{Implicit Calculus of Constructions} ($\text{ICC}^*$)~\cite{barras2008implicit}, which
  employs similar constructs for implicit dependent products.
Like conventional universal quantification, the arguments of $\forall$ types are
deduced during applications rather than being explicitly passed.
In addition, following designs for predicative higher-ranked polymorphism~\cite{oderskylufer,DK,PJ}, we have also generalized the concept of \emph{monotypes} to
\emph{mono-expressions} ($\tau$), essentially excluding $\forall$ types from expressions.

\paragraph{Recursion and Explicit Type-level Computation.}
\label{sec:cast}
The \name calculus adopts \emph{iso-types}~\cite{yang2016unified,yang2019pure},
featuring explicit type-level computation with cast operators
$\castdn$ and $\castup$. These operators respectively perform one-step
type reduction and type expansion based on the operational semantics.
The reduction in cast operators is deterministic, thus type
annotations are only needed during type expansions ($\castup$). We add
fixpoints ($[[mu x : A. e]]$) to support general recursion for both
term-level and type-level. Iso-recursive types are supported due to
the presence of $\castup$ and $\castdn$, which correspond to the
\verb|fold| and \verb|unfold| operations when working on iso-recursive types.

\subsection{Operational Semantics}

% \bruno{If I understand correctly we need 2 different reductions, one
%   (the non-deterministic one) that is used in the type system; and another
%   one (which erases types) that is deterministic and would be the basis
%   for an actual implementation of reduction at run-time. After reading
%   this subsection, I think we want
% to tell that story here and present the 2 variants of reduction here.}

For the operational semantics we employ two different, but closely related,
reduction relations. The first reduction relation is non-deterministic, and
it is used at the type-level to allow type conversions induced
by the cast operators. The second reduction relation is deterministic and
is employed to give the run-time semantics of expressions.

\paragraph{Nondeterministic Reduction.}
Figure \ref{fig:semantics} presents the small-step operational semantics of our system,
which mostly follows the call-by-name variant of \emph{Pure Iso-Type Systems} (PITS)
\cite{yang2019pure} corresponding to the calculus of constructions.
Note that the arguments of $\beta$-reduction (\rref{r-beta}) and expressions in
the \rref{r-cast-elim} are not required to be values.
Meanwhile we consider $\castup$ terms to be a value,
and only perform reduction inside $\castdn$ terms (\rref{r-castdn}). Also, the unroll
operation of the fixpoint operator is supported by \rref{r-mu}.

\begin{figure}[t]
    \centering

    \begin{drulepar}[r]{$[[e1 --> e2]]$}{Operational Semantics}
      \drule{app}
      \drule{beta}
      \and \ottaltinferrule{r-inst}{}{ }
        {[[(bind x : A. e1) e2 --> ([t / x] e1) e2]]}
      \drule{mu}
      \drule{castdn}
      \and \ottaltinferrule{r-cast-inst}{}{ }
        {[[castdn (bind x : A. e) --> castdn ([t / x] e)]]}
      \drule{castXXelim}
    \end{drulepar}

    \caption{Operational semantics of \name.}
    \label{fig:semantics}
\end{figure}
% \bruno{Do not use $mono~e$ in the figure.
%   You have the syntax $\tau$ and $\sigma$ to represent
% monotypes, so just use that instead.}

%\subsubsection{Nondeterministic Implicit Instantiations}
Due to the presence of instantiation of implicit parameters, the direct operational
semantics is not deterministic, and potentially not type-preserving because of
\rref{r-inst,r-cast-inst}. The indeterminacy is caused by the guess of $\tau$,
which can be an arbitrary monoexpression, since we do not have access to typing
information in the dynamic semantics.

\begin{figure}
  \label{fig:extraction}
  \centering
  \begin{equation*}
  \begin{array}{llcl}
      \text{Erased Expressions} & e, A, B & ~ \Coloneqq ~ & [[x]] \mid [[n]] \mid [[k]] \mid [[int]] \mid [[ee1 ee2]] \mid [[elambda x. ee]] \mid [[epi x : eA. eB]] \\
      & & \mid & [[ebind x. ee]] \mid [[eforall x : eA. eB]] \mid [[emu x. ee]] \mid [[ecastup ee]] \mid [[ecastdn ee]] \\
      \text{Erased Value} & ev & ~ \Coloneqq ~ & [[k]] \mid [[n]] \mid [[int]] \mid [[elambda x. ee]] \mid [[epi x : eA. eB]] \mid [[ebind x. ee]] \\
      & & \mid & [[eforall x : eA. eB]] \mid [[ecastup ee]]
  \end{array}
  \end{equation*}

  % The behavior of gather and align under this lipics template is extremely
  % weird, this is the best I can do :(
  \begin{gather*}
    \begin{align*}
    \extract{[[x]]} &= [[x]] &
    \extract{[[n]]} &= [[n]] &
    \extract{[[k]]} &= [[k]] &
    \extract{[[int]]} &= [[int]]
    \end{align*} \\
    \begin{align*}
     \extract{[[e1 e2]]} &= \extract{[[e1]]} ~ \extract{[[e2]]} & % \\ % \and
      \extract{[[mu x : A. e]]} &= \mu \, x. ~ \extract{[[e]]} \\
     \extract{[[lambda x : A. e]]} &= \lambda \, x. ~ \extract{[[e]]} & % \\ % \and
      \extract{[[pi x : A. B]]} &= \Pi \, x : \extract{[[A]]}. ~ \extract{[[B]]} \\
     \extract{[[bind x : A. e]]} &= \Lambda \, x. ~ \extract{[[e]]} & % \\ % \and
      \extract{[[forall x : A. B]]} &= \forall \, x : \extract{[[A]]}. ~ \extract{[[B]]} \\
     \extract{[[castup [A] e]]} &= \castup \, \extract{[[e]]} & % \\ % \and
      \extract{[[castdn e]]} &= \castdn \, \extract{[[e]]}
    \end{align*}
  \end{gather*}

  \drules[er]{$[[ee1 *--> ee2]]$}{Erased Semantics}
    {app,beta,elim,mu,castdn,castXXinst,castXXelim}
  \caption{Erased Expressions and Operational Semantics}
\end{figure}
% \bruno{You need to use something like a latex table/tabular,
% to neatly align the erasure function.}

\paragraph{Deterministic Reduction}
We address the issue of determinancy of the dynamic semantics with
a design similar to $\mathrm{ICC}^*$ \cite{barras2008implicit},
employing type-erased expressions. The erased expressions
essentially mirror the syntax and semantics
of normal expressions, except for the elimination of type annotations in $\lambda$,
$\Lambda$, $\mu$ and $\castup$ expressions.
Figure \ref{fig:extraction} shows the syntax of the erased expressions and
the companion operational semantics. Note that restrictions are imposed in the
typing rules to forbid the implicit parameter occuring in runtime-relevant part
of the expression, i.e. the erased expressions (see section \ref{sec:type-system}).
With such restriction, implicit parameters can be directly eliminated in
\rref{er-elim,er-cast-inst}. For a well-typed expression, the reduction of
its erasure is deterministic. The type safety of our system is built around
this idea and is discussed in \ref{sec:type-safety}.

\begin{figure}
    \centering
    \begin{drulepar}[wf]{$[[|- G]]$}{Well-formed Context}
      \mprset{sep=1.2em}
      \drule{nil}
      \drule[width=30em]{cons}
    \end{drulepar}

    \begin{drulepar}[s]{$[[G |- e1 <: e2 : A]]$}{Unified Subtyping}
      \mprset{sep=1.3em}
      \drule{var}
      \drule{lit}
      \drule{int}
      \drule{star}
      % \drule{abs}
      \and \ottaltinferrule{abs}{width=20em}
        {\rulehl{[[G |- A : k1]]} \\ [[G, x : A |- B : k2]] \\ [[G, x : A |- e1 <: e2 : B]]}
        {[[G |- lambda x : A. e1 <: lambda x : A. e2 : pi x : A. B]]}
      % \drule{app}
      \and \ottaltinferrule{s-app}{}
        {[[G |- t : A]] \\ [[G |- e1 <: e2 : pi x : A. B]]}
        {[[G |- e1 t <: e2 t : [t / x] B]]}
      \drule{pi}
      % \drule{bind}
      \and \ottaltinferrule{s-mu}{width=20em}
        {[[G |- t : k]] \\ [[G , x : t |- s : t]]}
        {[[G |- mu x : t. s <: mu x : t. s : t]]}
      \and \ottaltinferrule{s-bind}{width=20em}
        {\rulehl{[[G |- A : k]]} \\ [[G , x : A |- B : *]] \\
         [[G, x : A |- e1 <: e2 : B]] \\
         x \notin \mathrm{FV}(\extract{[[e1]]}) \cup \mathrm{FV}(\extract{[[e2]]})}
        {[[G |- bind x : A. e1 <: bind x : A. e2 : forall x : A. B]]}
      % \drule{mu}
      \drule{castup}
      \drule{castdn}
      % \drule{forallXXl}
      \and \ottaltinferrule{s-forall-l}{width=20em}
        {\rulehl{[[G |- A : k]]} \\ [[G |- t : A]] \\
         [[G , x : A |- B : *]] \\
         [[G |- [t / x] B <: C : *]]}
        {[[G |- forall x : A. B <: C : *]]}
      % \drule{forallXXr}
      \and \ottaltinferrule{s-forall-r}{width=20em}
        {\rulehl{[[G |- B : k]]} \\ [[G |- A : *]] \\
         [[G , x : B |- A <: C : *]]}
        {[[G |- A <: forall x : B. C : *]]}
      % \drule{forall}
      \and \ottaltinferrule{s-forall}{width=20em}
        {\rulehl{[[G |- A : k]]} \\ [[G , x : A |- B <: C : *]]}
        {[[G |- forall x : A. B <: forall x : A. C : *]]}
      \and \ottaltinferrule{s-sub}{width=15em}
        {[[G |- e1 <: e2 : A]] \\ [[G |- A <: B : k]]}
        {[[G |- e1 <: e2 : B]]}
    \end{drulepar}

    % \drules[s]{$[[G |- e1 <: e2 : A]]$}{Unified Subtyping}{
    %     var,lit,int,star,abs,pi,app,bind,mu,castup,castdn,forallXXl,forallXXr,forall,sub}
    \begin{equation*}
       \text{Syntactic Sugar} \qquad [[G |- e : A]] \triangleq [[G |- e <: e : A]]
    \end{equation*}
    \caption{(Sub)Typing Rules of \name.}
    \label{fig:typing}
\end{figure}
% \bruno{The figure and rules will need a little cosmetic work. Firstly, there are many rules
%   stacking up premises vertically. I think it is better to have multiple rules
%   horizontally (and only upto 2 or 3 vertical stacks of premises).
%   Secondly, we need to look at the layout carefully to use space efficiently.
%   At the moment there are rules like S-ABS that could be paired up with some other
%   rules side-by-side and use less space (at the same time it is nicer
%   if adjancent rules are somehow related: two cast rules; application/abstraction, etc).
%   We must organize the rules in a nicer way. Thirdly, I think that, for binders with
%   annotations, like $\lambda x : A. e$, we may want to use brackets on the arguments
%   to improve readability, as in $\lambda (x : A). e$. It is a bit hard to ``parse''
%   the syntax without a little bit of effort. If this change is implemented it would
%   affect the whole section, starting from syntax.
% }

\subsection{Unified Subtyping System}
\label{sec:type-system}

Figure \ref{fig:typing} shows the (sub)typing rules of the system. We adopt a
simplified design of unified subtyping~\cite{yang2017unifying}, where the subtyping rules and
typing rules are merged into a single typing judgment $[[G |- e1 <: e2 : A]]$.
% The originals design lean towards object-oriented features,
% supporting generalized top type and bounded quantification,
% while our work focus on the subtyping relation between polymorphic types.
% \bruno{The previous sentence is something to be mentioned in related work, not here.}

Unified subtyping solves the challenging issue of mutual dependency between typing
and subtyping in a dependently type system.
% \bruno{Make sure that the overview discusses this issue.}
The interpretation of this judgment is ``under context $[[G]]$, $[[e1]]$ is a
subtype of $[[e2]]$ and they are both of type $[[A]]$''.
In this form of formalization, the typing judgment $[[G |- e : A]]$ is a
special case of unified subtyping judgment $[[G |- e <: e : A]]$,
and the well-formedness of types $\Gamma \vdash A$ is expressed by
$[[G |- A : k]]$ where $k \in \{[[*]], [[box]]\}$.

Although unified, the typing rules can still be viewed as two parts, the ``typing'' part
(\rref{s-abs,s-app,s-bind,s-mu,s-castup,s-castdn,s-sub}) and the ``subtyping'' part
(\rref{s-pi,s-forall,s-forall-l,s-forall-r}). We follow a usual design for
typing rules for lambda abstraction and application, and the subtyping rule of
dependent function types ($\Pi$ type).
% \bruno{We should say something about the ``more standard'' rules here.
%   I think we can briefly explain them and point the
%   reader to Linus work for further details, while observing that the rules
%   here are essentially simplified version (due to the absence of bounded quantification)
% of his rules.}

\paragraph{Rules for Universal Quantification}
The subtyping rules for universal quantification (\rref{s-forall-l,s-forall-r}) follow
the spirit of the Odersky and L\"aufer's polymorphic subtyping~\cite{odersky1996putting,DunfieldJoshua2013Caeb},
where the subtyping relation is interpreted as a ``more general than'' relation.
A polymorphic type $[[forall x : A. B]]$
is more general than another type $C$ when its well-typed
instantiation is more general than $C$ (\rref{s-forall-l}). A polymorphic
type $[[forall x : B. C]]$ is less general than a type $A$,
if $C$ is is less general than $A$ when the argument with the polytype ($x:B$)
is abstracted out (\rref{s-forall-r}).

Notably our formalization is not a direct generalization of the polymorphic subtyping,
\rref{s-forall} axiomatizes the subtyping relation between two polymorphic types.
And additional premises are added to \rref{s-forall-l,s-forall-r} aside from the
ones we previously mentioned in section \label{sec:polymorphic-subtyping}
The motivations for these changes are discussed in more detail in section \ref{sec:adaptation}.

\paragraph{Mono-expression Restrictions}
As in other predicative relations (such as the one by Odersky and L\"aufer),
the type arguments for instantiation in \rref{s-forall-l} are
required to be mono-expressions, which has cascading effects on typing rules of
other expressions. The arguments for applications are required to be
mono-expressions, and the whole fixpoint expression is required to be a
mono-expressions. We shall
discuss the reason behind the restrictions in later sections.
\bruno{I feel that we may be deferring a bit too much explanation
to later sections, but lets come back to this after you write later sections.}

\paragraph{Kind Restriction for Universal Types}
\label{sec:kind-restriction}

For the kinding of types, we mainly follow the design of the Calculus of
Constructions~\cite{CoquandThierry1988Tcoc}. However, we specifically restrict
the $[[forall x : A. B]]$
expressions to only have the kind $[[*]]$. This prevents other types of kind
$[[*]]$ from having kinds such as $[[forall x : int. *]]$,
which significantly complicates the metatheory when reasoning about the kind of types.
This restriction propagates to the introduction rule of $\forall$ types (\rref{s-bind}),
where $[[B]]$ is required to only have kind $[[*]]$.
This way well-typed implicit abstractions ($\Lambda$ expressions) are kept away
from type computations. Therefore, in cast operators,
the possibility of non-deterministic implicit instantiations is eliminated.

\paragraph{Runtime Irrelevance of Implicit Arguments}

Our direct operational semantics choose random mono-expressions to instantiate
the implicit arguments which potentially breaks type safety, so we adopt a
restriction in \rref{s-bind} that is similar to the
Implicit Calculus of Constructions (ICC) \cite{miquel2001implicit}.
We only allowing the implicit parameters to occur in type annotations in the
body of implicit abstraction, so that the choices of implicit parameters is not
relevant at runtime. The type safety of the direct operational semantics is
proved indirectly in section \ref{sec:type-safety} with the help of the
erasure of expressions.

\paragraph{Redundant Premises}

All the premises highlight in gray are redundant in a way that
the system without them is proved equivalent to the system in figure \ref{fig:typing}.
They are there to simplify the mechanized proofs of certain lemmas.

